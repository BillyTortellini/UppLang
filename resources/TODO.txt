Current Work Item:
------------------
 * Functions with no return values
 * Structs
 * Syntax for new/delete

 Functions with no return values:
    main :: (x: int) -> void
 If i implement a void type, then the parser and the type system would not be concerned, only analyser, im-generator and code-generator
  This concerns:
    - Parser (AST_Node for function may not have a return value now)
    - Type_System (Currently all function types have a return value)
    - Semantic Analysis (You cannot move results from void functions to somewhere)
    - Intermediate Generator (Return must be able to return nothing)
    - Bytecode Generator (Return must be able to do nothing, also return type should not be loaded)

Long-Term Goals:
----------------
 * More language features
 * C-Backend
 * Debugger
 * Calling C-Functions
 * More Editor features

More Language features to implement:
------------------------------------
 * Structs
 * Syntax for new/delete
   ------- Before this I should implement some editor features (Linter at least) -------
 * Default variable initialization (0)
 * Primitive Types (And calculating with them, e.g. u8, u16, u32...) INFO: Array bounds check should then be done with u32, not i32, so negative values are detected
 * Casting (Float/Int implicit, from smaller to bigger implicit?, reinterpret cast thing)
 * Global Data
 * Strings
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
   ------- Before this I should fix all the editor bugs ------
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Function pointers, lambdas
 * Defer statement
 * Tagged Unions
 * Location-Information (Filename, line_number...)
 * Any-Type and Type access (Varargs in this language)
 * Code-Polymorphism (Template/Generic System)
 * Modules
 * Constant values (Maybe as the first iteration of the tag-system)
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)
 * Iterators
 * Macro-System
 * Context (Used for memory allocations, useful in Multi-Threading)

Editor features to implement:
-----------------------------
 * Linter (Auto formating)
 * Autocompletion (Question if I want it to be just a text featuer, or using the ast)
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)

Editor-Bugs:
------------
 * Repeat last search does not differentiate 'f'/'t'/forward backward
 * 'r' is buggy on line end, and on empty lines
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Program crashes)
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * % does not jump on empty parenthesis () {}
 * O does not work on first line
 * dd with numbers seems to not take the last number
 * put with 'dd'ed lines is also a bit weird
 * CTRL-W in insert mode deletes all newlines too

Ideas that need to be tested:
-----------------------------
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language
 * Using compile-time code-execution for metaprogramming and other stuff
 * Code-Analysis with data-value semantics (Tag System)
 * Hot-Code Reloading
 * Stack-Analysis for Debug information (Or others?)

Improvements that should be made (When I have time):
----------------------------------------------------
Replace all namespace ENUM types with enum class things.

Maybe we could also use String* for names, since then I only need to compare string pointers, and not actually strings.
This would also make debuggin so much easier, since we would see the names of things.

Semantic Analyse should keep the node_index of the first definition of each symbol (Symbol table), 
currently only true for functions. 
Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

Open Questions:
---------------
Should I change the function syntax? 
From
    main :: (x:int, y: int) -> int {}
To
    main(x: int, y: int) -> int {}
    main(x: int) -> 
Maybe, but i dont think it makes a big difference, and it wont work with structs or other fixed data
I actually quite like it, so I will probably do it 
The problem here is that function calls will look very similar to function definitions
    main(15);
    main(x: int){}
But function calls can only be done in expressions, so parsing this should be no problem!
I dont actually think i want this, the more i think about it. It does not make a difference and it may not make sense

How does the syntax for array initialization look like?
    C:
        int x[] = {1, 2, 3, 4, 5}; 
    UppLang:
        x: []int = [1, 2, 3, 4, 5]; // Could this be a potential problem with array access? -> Dont really think so

How do i implement dynamic arrays?
I think it would be really nice if the language would know about these
    x: [..]int;
    new [5]int;




