Current Work Item:
------------------
 * Implicit Casting
 * Rethink how literals work, maybe add more?
 * Array should have u64 as size, bounds checks needs adjustments
 * Member access with . on pointer

 Implicit Casting:
    - smaller to bigger int types/float to double
    - int to float/double (All int sizes, since floats can handle large values much better)
    - sized to unsized array
    - void ptr/ptr

 Explicit Casting:
    - bigger to smaller
    - unsigned/signed
    - Float to integer

 How do I handle Literals? --> I mean I could just keep them as i32/float for the time being

In which cases does implicit casting apply:
    Binary operations (When types dont match, i think i need special smth here, required type would be the bigger one I guess?)
        - Comparisons (== !=) should not have casting, less/equal stuff should
    Arguments in function calls (Here we have one required type and one given type)
    Assignment statement (Here we also have one required type and one given type)

 With literal handling i mean integer literals and floating point literals
    15
    0 
    -5
    0.0
    137.43
The problem is that it depends in which contexts they are used, how they should behave.
    



Long-Term Goals:
----------------
 * C-Backend
 * Calling C-Functions in the C-Backend (Maybe with Clang for header file parsing)
 * More language features
 * Calling C-Functions in Bytecode (Look into dyncall)
 * Debugger
 * More Editor features

More Language features to implement:
------------------------------------
 * Primitive Types (And calculating with them, e.g. u8, u16, u32...) INFO: Array bounds check should then be done with u32, not i32, so negative values are detected
 * Casting, Float/Int implicit, from smaller to bigger implicit?, reinterpret cast thing, Array sized to unsized, Member access with . on pointer
 * Global Data
 * Strings
 * Default variable initialization (0), probably
   ------- Before this I should fix all the editor bugs + C Backend or calling C functions ------
   ------- Here I also should check what I can add later, and what are necessary features for programming ------
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
 * Loop statements, maybe loop over array syntax
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Function pointers
 * Lambdas
 * Defer statement
 * Enums
 * Tagged Unions
 * Location-Information (Filename, line_number...)
 * Any-Type and Type access (Varargs in this language)
 * Code-Polymorphism (Template/Generic System)
 * Modules
 * Constant values (Maybe as the first iteration of the tag-system)
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)
 * Iterators
 * Macro-System
 * Context (Used for memory allocations, useful in Multi-Threading)

Editor features to implement:
-----------------------------
 * Autocompletion using current symbol table
 * Jump to definition with string search (Maybe Ctrl-F)
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits)
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

Ideas that need to be tested:
-----------------------------
 * Using compile-time code-execution for metaprogramming and static analysis
 * Code-Analysis with data-value semantics (Tag System)
 * Hot-Code Reloading
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Differentiate break_loop, break_switch
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language
 * Incremental Builds

Improvements that should be made (When I have time):
----------------------------------------------------
Make a parser check sanity function, that checks if the tree nodes are of the correct type
Replace all namespace ENUM types with enum class things.

Create a Compiler struct that holds all the relevant stuff
    * Lexer
    * Parser
    * Analyser
    * IM-Generator
    * Bytecode-Generator
    * Bytecode-Interpreter
And just call the Compiler from the text editor --> This has to be done eventually,
but then I need to rewrite how things are accessed through the compiler.

Maybe we could also use String* for names, since then I only need to compare string pointers, and not actually strings.
This would also make debuggin so much easier, since we would see the names of things.

Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

Open Questions:
---------------
How does the syntax for array initialization look like?
    C:
        int x[] = {1, 2, 3, 4, 5}; 
    UppLang:
        x: []int = [1, 2, 3, 4, 5]; // Could this be a potential problem with array access? -> Dont really think so

How do i implement dynamic arrays?
I think it would be nice? if the language would know about these
    x: [..]int;
    new [5]int;
Check out Jonathan Blows streams to check what hes doing

At which stage does metaprogramming/template instances/automatic code generation happen?
I currently almost think that I need another AST-Tree for this, since
I dont think I want to manipulate code on the Intermediate Representation level, due to
the Access things and the expression evaluation things and all this kinda complicated stuff.

This generally concerns me for defer, templates and macros, since doing this on an AST-Level
seems a lot simpler (This isn't confirmed yet). I could also split variable definitions in two things
(Currently define, define-assign, define-infer) and add implicit conversions or return statements when necessary.
Thought: I think templates can ONLY be done on the AST-Level, since the Intermediate Representation already has
exact instructions for binary operators and other stuff.




