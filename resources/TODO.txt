Next features:
--------------
 * Comptime declarations (Inner functions, inner structs...)
 * Bake with non primitive values, maybe functions
 * Read-only variables (Changes in constant propagator)
 * Function overhaul, e.g. Non-Pointer parameters constant, Named parameter values in function calls

 * Literal overhaul (Integers, floats, strings?, arrays are u64, array access with any int...)

 * Struct unpacking syntax, ignore syntax 
     index, found := find_elem(arr, 2);
     index, _ = find_elem(arr, 3);
     _ = Hashtable~insert();
     union {ipv4: int; ipv5 = _};

 * Conversion function to pointer and back

 * Templates rework (No more templated modules, templated types, templated functions)
 * Interpreter upgrade, call C-Functions, Custom allocator, check memory access
 * Macros and Iteration
 * Generating source code with runtime code execution
 * Annotations
 * Static Analyser
 


Design:


Implementation:
---------------
Currently there exists the Definitions node, which may contain the following children:
 * STRUCT, C_UNION, UNION, ENUM
 * MODULE, MODULE_TEMPLATED
 * FUNCTION
 * VARIABLE_DEFINE_ASSIGN, VARIABLE_DEFINE_INFER, VARIABLE_DEFINITION

 * EXTERN_FUNCTION; EXTERN_LIB; EXTERN_HEADER; LOAD_FILE

Issues:
-------

Known Bugs:
-----------
 - Sometimes active-switch is not found in switch-case nodes




How about beeing able to use function types in function/lambda definitions
    int_op: Type = (a: int, b: int) -> int;
    add :: bin_op 
    {
        return a + b;
    }
Would be really cool, but I think having some auto lambda function could also work.
    add: int_op: auto {return a + b;}
Generally lambdas could have an auto syntax, so i dont have to write the parameters + return value
    






Design Discussion: Constant/Readonly definitions + Constant Propagation
-----------------------------------------------------------------------
Lexicography:
    Constant ... A value known at compile-time. Can be used for optimizations
    Readonly ... A readonly variable that is only initialized once, at declaration. The value of this variable cannot/should not change

I obviously want to have Constant values, because multiple systems build on it, like templates, bake and compile-time execution.
The syntax is also pretty much set in stone right now, with it being quite similar to the variable definition syntax.

Constant Syntax works well because it supports type, functions and variables (And later maybe modules, but we will see about that):
    x :: 5; // Comptime integer
    x: u64: cast 5; 
    x :: #bake(Node) {...; return list.head;};
    x :: () -> int {};
    int_fn :: () -> int;
    x :: struct {}
    x: struct{a: int};

Why would I want a Readonly System in the language?
 * Parameters should not be changable, to allow the compiler to do optimizations with big structs (e.g. pass as pointer)
 * Comptime values should not be changable, because accessing them will at some point result in an error (Readonly pages in C-compilation)
 * Constant propagation would be a lot easier (Readonly variables can be better propagated then normal variables)
 * Readonly variables may be a cleaner solution in Code sometimes

Design questions:
 * Syntax for readonly
 * Pointer interaction with readonly
 * Struct/Union interaction with readonly
 * Should strings be readonly
 * Casting from/to readonly
 * Transitive readonly?

Thoughts:
    // Readonly values:
    x: readonly float = 3.2; // WORKS
    add :: readonly (a: int, b: int) -> int {return a + b;} // ERROR: expected type, not function
    Node :: readonly struct {value: int};                   // WORKS: Node now cannot be changed...

    // Readonly values cannot be changed
    x = 12.0;                      // ERROR, x is readonly
    node: readonly Node;           // ERROR, node is not initialized
    node: readonly Node = .{...};
    node.next &= whatever_node;    // ERROR, member accesses are not allowed on readonly variables
    xp :&= x;                      // WORKS, xp is now a pointer to readonly int
    xp = 5;                        // ERROR, trying to write to readonly value
    ip: *int = 5;                  
    ip &= x;                       // ERROR, cannot cast from *readonly int to *int

    // Pointers to Readonly values can also not be changed
    x: readonly int = 5;
    xp :&= x;
    xp = 7;                        // ERROR, trying to write to readonly int
    i := 5;                         
    xp = i;                        // WORKS,

    // Because readonly usually requires things to be initialized, it can also be added afterwards
    // This will cause problems with the constant propagation, but should still be possible to implement.
    x: int = 5;
    xp :&= x;
    x = x + 7;
    readonly x;
    xp = 7; // Now the readonly value changed to 7, but it still cannot be changed through the x symbol;

    // Constant structs:

    // Pointers/Slices inside structs:
    Node :: struct {
        value: int;
        next: &Node;
    }
    head: Node;
    head = Node.{value = 0; next &= null;};
    head.value += 1;
    readonly head;

    x := head.value + 1;  // WORKS, reading values is not a problem
    head.value += 1;      // ERROR, Everything that is accessed on a const type is now also const 
    x := head.next.value; // WORKS, 










---------------------------
------ ISSUE TRACKER ------
---------------------------

Issues:
-------
 * Templates
    - Structs and functions in templated modules may not use templates
    - Functions created during Template-Analysis should probably be deleted later
    - Globals are currently disabled in a template context
 * Globals
    - Global initializiation order is bad (Depends on dependencies of symbol definitions)

Long-Term Goals:
----------------
 * Debugger
 * Language features
 * Editor features (Search and replace, jump to definition, show context info, refactoring, Code LOD)
 * Maybe implementing Syntax guided Editor

More Language features to implement:
------------------------------------
 * Tag-System (For constant values, but also other stuff)
   ------- These features are for convenience, but they are not top priority ------
 * Array bounds checking would be good
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Literal overhaul (What is a float, what isnt...)
 * Loop statements, maybe loop over array syntax
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Code-Completion using current symbol table
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Metaprogramming with Compile-Time code execution
  * Static-Analyser with information exchange
  * Code-Visualizations in Editor (Maybe syntax guided editor)

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Compiler supported Dynamic-Array type
 * Hot-Reloading Code
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language 

Code Improvements that should be made (When I have time):
----------------------------------------------------
Hashing type signatures for lookup, not array search, or maybe use Graph-like data structure

Differentiation between errors and Warnings

Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

At some point the editor should not render at 60 FPS, but rather update when necessary.
Asynchronous Editor-Compiler architecture, lexing/parse/analysing in background when code gets bigger





----------------------------
------ RANTS/THOUGHTS ------
----------------------------

Syntax Design-Principles:
-------------------------
Some characteristics I want:
    - Compression based length (Often used constructs should be short, others can be long)
    - Easy to remember
    - Similar things should look similarly, different things should look different
    - Refactoring should be easy
    - Small refactorings should not cause unpredictable errors

Rant: On Serializability
------------------------
In C and C++, the program does not have access to type-information, meaning that something like automatic serialization is not possible inside the language.
    You could still do this by writing custom tools, which parse the code again (e.g. with clang) to get this type-information
    and create files containing serialization code (Was done by Valve Physics Engine Programmers), but this is -very- tedious and error-prone.
Even if this works, you cannot serialize all data, mainly because of pointers/references, which is the reason you cannot just memcopy data for serialization.
To solve this, some changes to C/C++ are required:
    - Dynamically Allocated arrays must have a size member (e.g. Slices in Upp have a size)
    - Void* may not be used inside these structures (You don't have any type information about that), which is solved with the Any-Type
A problem that still exists is that function pointers will not work/require special serialization effort.

Design Questions:
-----------------
 - Do anonymous structs duck-type?
        No, if this is useful, just define the struct
 - Should the unpacking syntax be allowed for structs as well?
        Yes, why should it not, makes refactoring easier
 - Named argument passing?
        This seems to overlap a lot with struct initilization, since struct initialization IS basically just
        calling a function, but the function exists already for each Struct type
        Maybe I want struct initialization to require naming the arguments, and not for functions
        Not exactly the same, since Union initialization is 
 - With anonymous structs, how are they instanciated?

Design Ideas:
-------------
 - Function parameters are constant, parameters may be passed as pointers if they are too big
 - Functions can only return one value, but it may be an anonymous struct
 - Function return value cannot be dropped, ignore syntax (_ = do_smth();)
 - Unpacking syntax for anonymous structs (x, y = returns_anonymous();)

Design: Multiple returns:
-------------------------
I feel like I want a clear destinction between in, out and in-out parameters of functions
    in: Normal, non-pointer parameters, passed as values
    in-out: Pointer parameters
    out: Return-values

In C you cannot have a clear distinction between these three, because: 
    - You dont want to pass huge structs/unions by pointer  --> Therefore pointer arguments may be in
        In C++ you have constant references, do_smth(const int& smth)
        In Rust/Zig arguments are always constant, and the compiler decides wheter or not they are passed as pointers
    - You cannot have multiple return values                --> Either have a parameter-pointer that is written to, or create and return a struct
        Either support multiple return values, or some tuple types/anonymous structs as returns


Thoughts on pointers:
---------------------
UPDATE:
Pointers acting exactly the same as values is, I think, a great idea. The only problem we have are
situation where a pointer operation could also be used instead of a value operation. 
The question I am having is wheter or not I want to have special syntax to solve this problem. 
The current operations that accept both pointers and values are:
    - Equals-Comparisons (== and !=)
    - Cast to u64 (cast(u64))

Pointers are essential in Computer programming, and I want them in the language
Null seems to be an issue for a lot of programmers, but this should be handled by the static analyzor
Pointers are used for call by reference,
Pointers are also used to have multiple return values
Pointers are also used to not pass huge structures by value, since this requires copying

If you think about function parameters as either in, out or in_out parameters,
pointers in C basically combine all of those into one feature.
This makes some APIs kinda shitty, because seeing a pointer does not provide the user
information about nullable, if its an in, out or in_out value. 

In Upp I think I want a distinction of these type by having the following:
 - Non-Pointer parameters are constant (So that huge structs can be passed internally by pointer without requiring a copy), 
    although I have to think about constant pointers inside of structs
 - Pointer parameters could in theory be all types of parameters (in, out, in_out), but should only be used for in_out
    which is definitly something that is gonna be required quite often
 - With multiple return values there is no need to use pointers for return values

In C pointers are also used as arrays, with pointer arithmetic being a thing (- and + being defined for pointers)
This also leads to the use of stacked pointers, (char** argv, where argv is actually an array to char*, so []String in my language)
The operations required on pointers in C are:
    - Address-Of    int* xp = &x;
    - Dereference   *xp = *xp + 1;
    - Array-Access  item = xp[2];
    - Arithmetic    item = *(xp + 2);
                    ip   = xp + 2;
                    diff = ip - x;

I would like to be pointers to be as interchangable with values as possible, to do that I want
to pass around the expected_type of expressions 




Syntax what operators are in use:
---------------------------------
    +   ... Addition
    -   ... Subtraction, Unary negate
    *   ... Multiplication/Address Of/Pointer type constructor
    &   ... Dereference
    /   ... Division
    %   ... Modulo
    !   ... Logical not

    <   ... Less 
    >   ... Greater
    <=  ... Less Equals
    >=  ... Greater Equals
    ==  ... Equals
    !=  ... Not Equals

    &&  ... Logical And
    ||  ... Logical Or

    ()  ... Function call/Function definition
    []  ... Array definition/Index operation
    {}  ... Code Block operation
    <>  ... Template argument parenthesis

    "   ... String delimiters
    #   ... Extern declarations (#load)
    .   ... Member access/Auto access
    ;   ... Statement delimiter
    ,   ... List item delimiter

    :   ... Variable definition
    :=  ... Define-Infer
    ::  ... Constant Definition
    ->  ... Function return value

    //  ... Single line comment
    /*  ... Multiline comment start
    */  ... Multiline comment end

Currently unused but plans exist:
    _   ... Unused value in multiple returns
    '   ... Char delimiter (Not implemented yet)
    $   ... Fast Template declaration (Not implemented yet)
    @   ... Annotations
    \   ... String delimiters

Open Characters and normal usage
    ~   ... Bitwise Negate
    ^   ... Bitwise XOR
    &   ... Bitwise And
    |   ... Bitwise Or
    >>  ... Bitshift right
    <<  ... Bitshift left
    ?   ... Ternary Operator
    °   ... Nothing
    




Ideas that just come to mind:
-----------------------------
PrintF Debugging could be replaced with memory visualizer
'Destructors' could be generated with metaprogramming, simple initializors too
Advanced initializers could also be generated with metaprogramming and Annotations
Differentiate States and Tags in the language
Should we have compile-time known arguments, are they the same as template args?
Context struct could live in thread-local memory
Syntax guided editor would be cool I guess
Are stacked pointers a reasonable idea (**int)? Where would i use them
Automated parameter deduction (Like macros taking names from outer scope)
Meta-Programming code modifications may be easy if executed code must be unmodified, and only finaly code is modified
Strings should probably just be byte slices (int + pointer) and be immutable, and we'll just have a String_Builder for output

Code Ideas:
-----------
Type_System should maybe do more, like templates, parameter names, struct names
Symbol template infos add info if symbol is templated
Maybe think about making initializers helpers for expressions/statements?
Const expression evaluation maybe after creation?
Redo template syntax, only allow on functions/structs
Delete IR_Code, just use modtree for translation
Functions may just be compile time known function pointers?
Hardcoded functions should be removed at some point
AST_Node only really needs type and child information for processing, parent and tokenrange could be in another array and multiple structures could exist for this
ModTree and IR_Code Structure is probably not final, but well see when we know more
Workload-Structure may be easier if we could analyse the dependencies beforehand -->
    Maybe implement pre-analysis step, so that Workloads dont need Pauses/Wait for dependencies
Custom allocator for Bytecode-Interpreter, check pointers if they are in range, have custom boolean
    which can be toggled to indicate that C-Functions may be called
Initialize all variables to zero in Bytecode

Thought Run-Down:
-----------------
Maybe remove single statement blocks, e.g. if (bool) return false;
Just replace these with if (cond) {return false;}

Anonymous structs:
    x: struct {name: String; value: int;};
    x.name = "Henlo";
    x.value = 5;
    x = .{name = "Henlo"; value = 15;};

Return value may be struct
    find_elem(...) -> struct{found: bool; index: int;}
    return .{found = true; index = 15;};

Values may be left explicitly uninitialized
    .{found = _, index = 15};

Struct unpacking syntax
    found, index := find_elem(...);
    f2, _ := find_elem(...);

Return values must be explicitly ignored:
    _ = hashtable_add_element(whatever...);

Lambda support
    x := () {print_string("What");};
    adder := (x: int, y: int) -> int {return x + y;};

Choosing enum type
    Something :: enum<int> {}
    Smaller :: enum<byte> {}

Expression_Blocks?
    UPDATE: Currently i think these are a bad idea, because return does something else inside these blocks,
        and I could introduce the concept of yield, which would return a value, but I don't think this is necessarily useful.
        The Idea behind expression blocks would be to give more purpose to an unnamed block. E.g.

        The 2 main use cases I have for these are :
            * a short way to write if's and switches
            * Make sure some values are initialized

            The main use cases I can think of are:
                * a short way to write if's and switches
                * Makes sure values are going to be initialized
                * Gives purpose to values (E.g. you know where the values are going to be used)

            Problems:
                * Syntax overlap inside if, switch, while --> Not true with extra syntax, e.g. #{}
                * They may be quite unnecessary, because function can do the same thing
                * ModTree_Code's structure of expressions and statements isn't exactly build for this
                * Would definitly need some experimentation

        fn_call(15, {if condition {yield make_unknown();} yield make_known(condition);});

    found, index: bool, int = {
        
    }

    of 
    expression.index, expression.is_templated = {

    };

    x = {switch color {case .RED: return 5; case .GREEN: return 2;}}
    x = {if a return 4; return 2;}
    z = 32 + {if alive return 17; return -2;}
    min_member: *Struct_Member = 0;
    {
        curr_min: *Struct_Member = members[0];
        loop mem in members {
            if mem.val < curr_min.value curr_min = mem;
        }
        if (curr_min.alive != 0) {
            min_member = curr_min;
        }
    }
    
    // Why could this be useful? Because it gives the code block a distinct purpose, and its impossible to not set the values 
    found, member: bool, *Member = 
    {
        ret_type :: struct {f: bool; mem: *Member};
        loop a in array {
            if condition_met(a) {
                return ret_type{f = true, mem = a};
            }
        }
        return ret_type{f = false, mem = _};
    } 

    // Also some things can be typed rather quickly
    based_num := {if is_based return 69; return 0;};

NOTES:
------
 * Next stuff:
    - Jump to definition fix --> A separate analysis/code generation phase would be nice
    - Code_Completion
 * Improve Language:
    - Compile time code-evaluation
    - Tag-System + Static Analyis
 * Improve Editor:
    - Multiple projects
    - Code-Completion
    - Search and Replace


Metaprogramming features:
-------------------------
 * Templates (Types for Containers, Functions/Values for algorithms and interfaces)
 * Macro System (Iterators, Scope_Break, Variable_Define, Code_Insertion... lots of convenience functions)
 * Defer
 * #if (Conditional Compilation)
 * Currying
 * AST-Manipulation (Compile time Execution)
 * Generating source-code (Compile time Execution)








