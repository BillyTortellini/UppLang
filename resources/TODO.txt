Next features:
--------------
 * RC_Generator all features implemented

 * Better Dependency-Graph resolution
 * Bake expressions, bake function pointers
 * Conversion function to pointer and back
 * Literal overhaul (Integers, floats, strings?, arrays are u64, array access with any int...)
 * Array bounds check

 * Polymorphism (Template rework: No more templated modules, templated types, templated functions)
 * Macros and Iteration 
 * Generating source code with runtime code execution (#insert_code {return "what the fuck";})
 * Annotations (Used in generating source code)
 * Static Analyser

 * New with values?
 * Interpreter upgrade, call C-Functions, Custom allocator, check memory access
 * Function overhaul, e.g. Non-Pointer parameters constant, Named parameter values in function calls
 * Read-only variables
 * Struct unpacking syntax, ignore syntax 
     index, found := find_elem(arr, 2);
     index, _ = find_elem(arr, 3);
     _ = Hashtable~insert();
     union {ipv4: int; ipv5: _};




Reimplement the following features:
Then assure that the test-cases all work, afterwards, fix the following issues

Issues:
 - Auto-Cast on function parameters doesnt' work, REWORK Expression_Context



REWORK Expression_Context:
Goal: 
 - I would like to use the expression context to do implict/explicit casting
 - Expression_Context

How is the current Context used:
 - Pointers to values
 - Address-Of
 - Auto-Cast
 - Auto Struct Initializer
 - Auto Array-Initializer
 - Auto Enum

Auto cast carries around the type that i

What should expression context do:
 - If i know the precise type, it should be able to report errors and do implicit casting
 - 

Why doesn't assignment do auto pointer references?

i: int;
ip: *int;
x: int;
xp: *int;

x = i;   
x = ip;  
xp = i;
xp = ip;







Over night Thoughts:
--------------------
Casting should be done in the expression context, and the context can just create errors, since we already
have analyse expression internal and all that good stuff. 

I probably want to remove modtree now, and stick with ir-code, since ModTree is kinda useless now.
Definitly true, because the modtree expression/statement is kinda bad for code generation, ngl

Analysis timing is very inconsisten, maybe I should do more timing tests for it















Design Discussion: Templates (OLD)
----------------------------
Open Questions:
 * Functions inside templated functions
 * How does type-checking work for templated functions 

Why are templates usefull/what purpose do they have?
They are usefull because there are multiple usecases where a programmer wants to reuse the same Code with
just change some small things about it. For example, to have a typesave Container, withouth templates, 
one would either need other metaprogramming capabilities (E.g. Macros in C, some code-generation tool...)
or sacrifice Type-Safety/Speed (E.g. use Any-Type, Java Object...). 
This is especially true if you want Code that works on multiple types, but requires instances of the type to be on the stack,
since this cannot easily be done without metaprogramming or custom assembly.
Although the main use of this is with containers, it is also usefull for values, e.g. for Vectors, or Conditionall-Compilation, 
or calling different functions without function pointers

Lets first look at how other languages approach this problem:
    Zig: There is the concept of comptime parameters, and types can be returned from functions, which are automatically
    executed at compiletime I guess?
    fn List(comptime T: type) type {
        return struct {
            items: []T,
            len: usize,
        };
    }

    C/C++: Here you use custom template syntax to indicate that the function/struct is using templates
    template<typename T, int count>
    struct Array {
        T data[count];
    };

    Odin: 
    ip: *int = *i;
    If you put a $ before the variable definition, this means that it must be compile time known:
    foo :: ($T: Type, slice: []T, index: int) -> T {
        return slice[index];
    }
    foo(int, int.[1, 2, 3], 2); // Returns 3

    If you put the $ before a parameter type, this means that the type is infered from the passed parameter
    foo :: (slice: []$T, index: int) -> T {
        return slice[index];
    }
    foo(int.[1, 2, 3], 1); // Returns 2;

    Jai:
    This is basically the same as in Odin, but there are also:
     * #modify
     * #bake (For parameters)

How do I want to approach this problem?
Probably the same as in Jai and Odin, but since I also have comptime code execution it will
be more similar to Jai. 

Two things that bother me:
It seems like both Jai and Odin are kind-of using Duck-Typing in their Generic approach:
    add :: (a: $T, b: T) -> T {return a + b;}
    return_mem_x :: (a: $T) -> int {return a.x;}
I don't understand how this can be analysed to check if the code is correct, e.g.
    foo :: (a: $T)
    {
        x := a.x;
        // Or
        y := bar(a);
        info := type_info(y);
        x = other_fn(x, 15);
        a.x = a.x * x;
        x.value = 15;
    }
To be fair this seems possible to implement, template types are just able to be used in operations, e.g., but the result is not specified

Mem_Interface :: struct(T: Type) {
    access_mem: (value: *T) -> int;
}
But my first thought was that all operations on templated types must also be specified, except assignment
    foo :: (a: $T, $interface: Mem_Interface(T))
    {
        x := interface.access_mem(a);
    }

But do I actually have any good reasons why this shouldn't be allowed?
 * Without this, I can check that the templated thing works without Problems --> Probably wrong because of bake/modifiy
 * With this, I already have easily defined interfaces/traits in the language for metaprogramming

foo :: (a: $T)
{
    #run {
        if (type_info(T).size < 8) {
            Compiler~error("Size of Type must be greater than 8");
        }
    }
    x := false;
    y := x + 5; // Obviously I want this 2 error now
    a :: size_of(T);
    #insert {
        str := "x = x + 1;";
        return str;
    }
    #if a > 16
    {
    }
    #else
    {
    }
}
// To be fair, until I have some crazy stuff, I probably just want to analyse and check if I can detect
// any errors.

partial_order :: (left: $T, right: T) -> bool;
sort_array :: (array: []$T, less_fn: (a: T, b: T) -> bool)
{
    if less_fn(array[j], array[j])
    {
    }
}

The reason that C++ has Constacts, Java has Interfaces + Generict matching thing and Rust has Traits is that
in Polymorphic/Templated/Generic Code it is sometimes requires that a given type has some given properties.
These could be:
    * has a member of name x of type int
    * has a member-function with a given signature
    * has a given unary operator defined on it
    * has an overloaded operator defined

In Jai and Odin, it seems like you just get an error, but I feel like I just want to pass a constant function as parameter to
handle these cases. Maybe I should checkout what Zig does.
    










All extern source declarations:
#load "whatever.upp";
#extern "cstdio" { ID0 ID1 ID2 }
#extern fn_name :: (); 
#extern lib "test.lib"; 

/*
To be fair at some point I want to be able to load extern sources from code.
#run {
    Compiler~load_file("whatever.upp");
    Compiler~define_extern_header("adder", (a:int, b:int)->int);
    Compiler~load_c_header("cstdio");
    Compiler~add_lib("test.lib");
}
*/





Design Discussion: Constant/Readonly definitions + Constant Propagation
-----------------------------------------------------------------------
Lexicography:
    Constant ... A value known at compile-time. Can be used for optimizations
    Readonly ... A readonly variable that is only initialized once, at declaration. The value of this variable cannot/should not change

I obviously want to have Constant values, because multiple systems build on it, like templates, bake and compile-time execution.
The syntax is also pretty much set in stone right now, with it being quite similar to the variable definition syntax.

Constant Syntax works well because it supports type, functions and variables (And later maybe modules, but we will see about that):
    x :: 5; // Comptime integer
    x: u64: cast 5; 
    x :: #bake(Node) {...; return list.head;};
    x :: () -> int {};
    int_fn :: () -> int;
    x :: struct {}
    x: struct{a: int};

Why would I want a Readonly System in the language?
 * Parameters should not be changable, to allow the compiler to do optimizations with big structs (e.g. pass as pointer)
 * Comptime values should not be changable, because accessing them will at some point result in an error (Readonly pages in C-compilation)
 * Constant propagation would be a lot easier (Readonly variables can be better propagated then normal variables)
 * Readonly variables may be a cleaner solution in Code sometimes

Design questions:
 * Syntax for readonly
 * Pointer interaction with readonly
 * Struct/Union interaction with readonly
 * Should strings be readonly
 * Casting from/to readonly
 * Transitive readonly?

Thoughts:
    // Readonly values:
    x: readonly float = 3.2; // WORKS
    add :: readonly (a: int, b: int) -> int {return a + b;} // ERROR: expected type, not function
    Node :: readonly struct {value: int};                   // WORKS: Node now cannot be changed...

    // Readonly values cannot be changed
    x = 12.0;                      // ERROR, x is readonly
    node: readonly Node;           // ERROR, node is not initialized
    node: readonly Node = .{...};
    node.next &= whatever_node;    // ERROR, member accesses are not allowed on readonly variables
    xp :&= x;                      // WORKS, xp is now a pointer to readonly int
    xp = 5;                        // ERROR, trying to write to readonly value
    ip: *int = 5;                  
    ip &= x;                       // ERROR, cannot cast from *readonly int to *int

    // Pointers to Readonly values can also not be changed
    x: readonly int = 5;
    xp :&= x;
    xp = 7;                        // ERROR, trying to write to readonly int
    i := 5;                         
    xp = i;                        // WORKS,

    // Because readonly usually requires things to be initialized, it can also be added afterwards
    // This will cause problems with the constant propagation, but should still be possible to implement.
    x: int = 5;
    xp :&= x;
    x = x + 7;
    readonly x;
    xp = 7; // Now the readonly value changed to 7, but it still cannot be changed through the x symbol;

    // Constant structs:

    // Pointers/Slices inside structs:
    Node :: struct {
        value: int;
        next: &Node;
    }
    head: Node;
    head = Node.{value = 0; next &= null;};
    head.value += 1;
    readonly head;

    x := head.value + 1;  // WORKS, reading values is not a problem
    head.value += 1;      // ERROR, Everything that is accessed on a const type is now also const 
    x := head.next.value; // WORKS, 




-------------------------------
--- IMPLEMENTATION THOUGHTS ---
-------------------------------
RUNNABLE/STRUCT_REACHABLE: 
--------------------------
The problem both bake and Compile/Runnable share is that the workload depends
on other Workloads of the same type, e.g.
   * Runnable requires all called functions to be runnable
   * Reachable requires all referenced/contained members to be reachable

This would work fine with a dependency graph, but the problem here is that
 - Circular Dependencies are NOT an Error, but rather something that happens often

This structure seems to imply that these Workloads need to be executed in Clusters, 
where one Cluster is a Set of Workloads that are all reachable from one to another, which is what 
I have done currently. 



CONTROL_FLOW:
-------------
Flow Types:
    * Sequential 
    * Stops      
    * Returns 

Break behavior:
 - If a break is reachable, all blocks up to the broken block have sequential flow

Loop behavior
    Sequential, (Is fine)                               -> Return Sequential
    Stops       (must also be fine because of continue) -> Return Sequential
    Returns     (Error because loop only runs once)     -> Return Returns

Conditional Rules:
 - If all branches return the same flow, the result-flow is that flow
 - If one branch is sequential, the result is sequential
 - Otherwise we have a mix of Stops and Return, which results in Stops

 

DEFERS:
-------
Defer: Mechanics are perfectly fine as they were before.
Triggers:
 - SCOPE/FUNCTION End
 - Return
 - Break/Continue --> Resolves it to the correct outer scope.

Defer stuff to think about
 - No defers inside other defers (I think this should work...)
 - Continue/Break lables must be in the given defer --> I don't think thats true because Defer currently stay in the same scope
 - Returns inside defers are not allowed? (I feel like the usecases of that are very limited)
 - Flow of defer? With no return

So current Solution:
 - No Defers inside Defers
 - No Break/Continue/Return inside defer (Control-Flow Changes)

Implementation:
 - Keep a stack of Modtree_Blocks as active defer blocks
 - Keep a stack of active defers (RC_Statement_Blcoks) 
 - ModTree_Blocks contain the start_defer index 
 - And then I can reevaluate defer on each of those blocks




Implementation:
---------------
Todo:
 - Instanciation of Polymorphic functions
 - Polymorphic Functions Note: Return type may be dependent on a constant argument
 - Partial Compilations tracks dependencies of functions, but not of poly funciton instances, this has to be added
 - Maybe we have a problem with shadowing, where shadows aren't detected anymore...
 - Constant_Pool deduplication would be nice at some point

Done:
 - Rework Function Header analysis with Poly-Function

Use-Case/Design:
----------------
foo :: ($T: Type, x: T) -> T {
    other := x;
    other.value = 5;
    return other;
}

Facts:
------
 * A polymorphic function cannot be called, only an instance of it
 * An instance will always have a valid type-signature (E.g. without comptime variables or polymorphic types)
 * The only two usages after function declaration is: Taking a function pointer, or calling the function
 * When ModTree function signature is 0, then a header analysis dependency is returned

Implementation Helper Facts:
 * ModTree function stores functions, but more importently, it is the argument to pass to the ir_code generator
 * So it seems like having another Modtree-thing, e.g. ModTree_Poly_Function would be more fitting
 * Symbols will then be able to refer to ModTree_Poly_Functions, expression results will return those...







---------------------------
------ ISSUE TRACKER ------
---------------------------
Long-Term Goals:
----------------
 * Debugger
 * Language features
 * Editor features (Search and replace, jump to definition, show context info, refactoring, Code LOD)
 * Maybe implementing Syntax guided Editor

More Language features to implement:
------------------------------------
 * Tag-System (For constant values, but also other stuff)
   ------- These features are for convenience, but they are not top priority ------
 * Array bounds checking would be good
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Literal overhaul (What is a float, what isnt...)
 * Loop statements, maybe loop over array syntax
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Code-Completion using current symbol table
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Metaprogramming with Compile-Time code execution
  * Static-Analyser with information exchange
  * Code-Visualizations in Editor (Maybe syntax guided editor)

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Compiler supported Dynamic-Array type
 * Hot-Reloading Code
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language 

Code Improvements that should be made (When I have time):
----------------------------------------------------
Hashing type signatures for lookup, not array search, or maybe use Graph-like data structure

Differentiation between errors and Warnings

Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)

At some point the editor should not render at 60 FPS, but rather update when necessary.
Asynchronous Editor-Compiler architecture, lexing/parse/analysing in background when code gets bigger





----------------------------
------ RANTS/THOUGHTS ------
----------------------------

Syntax Design-Principles:
-------------------------
Some characteristics I want:
    - Compression based length (Often used constructs should be short, others can be long)
    - Easy to remember
    - Similar things should look similarly, different things should look different
    - Refactoring should be easy
    - Small refactorings should not cause unpredictable errors

Rant: On Serializability
------------------------
In C and C++, the program does not have access to type-information, meaning that something like automatic serialization is not possible inside the language.
    You could still do this by writing custom tools, which parse the code again (e.g. with clang) to get this type-information
    and create files containing serialization code (Was done by Valve Physics Engine Programmers), but this is -very- tedious and error-prone.
Even if this works, you cannot serialize all data, mainly because of pointers/references, which is the reason you cannot just memcopy data for serialization.
To solve this, some changes to C/C++ are required:
    - Dynamically Allocated arrays must have a size member (e.g. Slices in Upp have a size)
    - Void* may not be used inside these structures (You don't have any type information about that), which is solved with the Any-Type
A problem that still exists is that function pointers will not work/require special serialization effort.

Design Questions:
-----------------
 - Do anonymous structs duck-type?
        No, if this is useful, just define the struct
 - Should the unpacking syntax be allowed for structs as well?
        Yes, why should it not, makes refactoring easier
 - Named argument passing?
        This seems to overlap a lot with struct initilization, since struct initialization IS basically just
        calling a function, but the function exists already for each Struct type
        Maybe I want struct initialization to require naming the arguments, and not for functions
        Not exactly the same, since Union initialization is 
 - With anonymous structs, how are they instanciated?

Design Ideas:
-------------
 - Function parameters are constant, parameters may be passed as pointers if they are too big
 - Functions can only return one value, but it may be an anonymous struct
 - Function return value cannot be dropped, ignore syntax (_ = do_smth();)
 - Unpacking syntax for anonymous structs (x, y = returns_anonymous();)

Design: Multiple returns:
-------------------------
I feel like I want a clear destinction between in, out and in-out parameters of functions
    in: Normal, non-pointer parameters, passed as values
    in-out: Pointer parameters
    out: Return-values

In C you cannot have a clear distinction between these three, because: 
    - You dont want to pass huge structs/unions by pointer  --> Therefore pointer arguments may be in
        In C++ you have constant references, do_smth(const int& smth)
        In Rust/Zig arguments are always constant, and the compiler decides wheter or not they are passed as pointers
    - You cannot have multiple return values                --> Either have a parameter-pointer that is written to, or create and return a struct
        Either support multiple return values, or some tuple types/anonymous structs as returns


Thoughts on pointers:
---------------------
UPDATE:
Pointers acting exactly the same as values is, I think, a great idea. The only problem we have are
situation where a pointer operation could also be used instead of a value operation. 
The question I am having is wheter or not I want to have special syntax to solve this problem. 
The current operations that accept both pointers and values are:
    - Equals-Comparisons (== and !=)
    - Cast to u64 (cast(u64))

Pointers are essential in Computer programming, and I want them in the language
Null seems to be an issue for a lot of programmers, but this should be handled by the static analyzor
Pointers are used for call by reference,
Pointers are also used to have multiple return values
Pointers are also used to not pass huge structures by value, since this requires copying

If you think about function parameters as either in, out or in_out parameters,
pointers in C basically combine all of those into one feature.
This makes some APIs kinda shitty, because seeing a pointer does not provide the user
information about nullable, if its an in, out or in_out value. 

In Upp I think I want a distinction of these type by having the following:
 - Non-Pointer parameters are constant (So that huge structs can be passed internally by pointer without requiring a copy), 
    although I have to think about constant pointers inside of structs
 - Pointer parameters could in theory be all types of parameters (in, out, in_out), but should only be used for in_out
    which is definitly something that is gonna be required quite often
 - With multiple return values there is no need to use pointers for return values

In C pointers are also used as arrays, with pointer arithmetic being a thing (- and + being defined for pointers)
This also leads to the use of stacked pointers, (char** argv, where argv is actually an array to char*, so []String in my language)
The operations required on pointers in C are:
    - Address-Of    int* xp = &x;
    - Dereference   *xp = *xp + 1;
    - Array-Access  item = xp[2];
    - Arithmetic    item = *(xp + 2);
                    ip   = xp + 2;
                    diff = ip - x;

I would like to be pointers to be as interchangable with values as possible, to do that I want
to pass around the expected_type of expressions 




Syntax what operators are in use:
---------------------------------
    +   ... Addition
    -   ... Subtraction, Unary negate
    *   ... Multiplication/Address Of/Pointer type constructor
    &   ... Dereference
    /   ... Division
    %   ... Modulo
    !   ... Logical not

    <   ... Less 
    >   ... Greater
    <=  ... Less Equals
    >=  ... Greater Equals
    ==  ... Equals
    !=  ... Not Equals

    &&  ... Logical And
    ||  ... Logical Or

    ()  ... Function call/Function definition
    []  ... Array definition/Index operation
    {}  ... Code Block operation
    <>  ... Template argument parenthesis

    "   ... String delimiters
    #   ... Extern declarations (#load)
    .   ... Member access/Auto access
    ;   ... Statement delimiter
    ,   ... List item delimiter

    :   ... Variable definition
    :=  ... Define-Infer
    ::  ... Constant Definition
    ->  ... Function return value

    //  ... Single line comment
    /*  ... Multiline comment start
    */  ... Multiline comment end

Currently unused but plans exist:
    _   ... Unused value in multiple returns
    '   ... Char delimiter (Not implemented yet)
    $   ... Fast Template declaration (Not implemented yet)
    @   ... Annotations
    \   ... String delimiters

Open Characters and normal usage
    ~   ... Bitwise Negate
    ^   ... Bitwise XOR
    &   ... Bitwise And
    |   ... Bitwise Or
    >>  ... Bitshift right
    <<  ... Bitshift left
    ?   ... Ternary Operator
    °   ... Nothing
    




Ideas that just come to mind:
-----------------------------
PrintF Debugging could be replaced with memory visualizer
'Destructors' could be generated with metaprogramming, simple initializors too
Advanced initializers could also be generated with metaprogramming and Annotations
Differentiate States and Tags in the language
Should we have compile-time known arguments, are they the same as template args?
Context struct could live in thread-local memory
Syntax guided editor would be cool I guess
Are stacked pointers a reasonable idea (**int)? Where would i use them
Automated parameter deduction (Like macros taking names from outer scope)
Meta-Programming code modifications may be easy if executed code must be unmodified, and only finaly code is modified
Strings should probably just be byte slices (int + pointer) and be immutable, and we'll just have a String_Builder for output

Code Ideas:
-----------
Type_System should maybe do more, like templates, parameter names, struct names
Symbol template infos add info if symbol is templated
Maybe think about making initializers helpers for expressions/statements?
Const expression evaluation maybe after creation?
Redo template syntax, only allow on functions/structs
Delete IR_Code, just use modtree for translation
Functions may just be compile time known function pointers?
Hardcoded functions should be removed at some point
AST_Node only really needs type and child information for processing, parent and tokenrange could be in another array and multiple structures could exist for this
ModTree and IR_Code Structure is probably not final, but well see when we know more
Workload-Structure may be easier if we could analyse the dependencies beforehand -->
    Maybe implement pre-analysis step, so that Workloads dont need Pauses/Wait for dependencies
Custom allocator for Bytecode-Interpreter, check pointers if they are in range, have custom boolean
    which can be toggled to indicate that C-Functions may be called
Initialize all variables to zero in Bytecode

Thought Run-Down:
-----------------
Maybe remove single statement blocks, e.g. if (bool) return false;
Just replace these with if (cond) {return false;}

Anonymous structs:
    x: struct {name: String; value: int;};
    x.name = "Henlo";
    x.value = 5;
    x = .{name = "Henlo"; value = 15;};

Return value may be struct
    find_elem(...) -> struct{found: bool; index: int;}
    return .{found = true; index = 15;};

Values may be left explicitly uninitialized
    .{found = _, index = 15};

Struct unpacking syntax
    found, index := find_elem(...);
    f2, _ := find_elem(...);

Return values must be explicitly ignored:
    _ = hashtable_add_element(whatever...);

Lambda support
    x := () {print_string("What");};
    adder := (x: int, y: int) -> int {return x + y;};

Choosing enum type
    Something :: enum<int> {}
    Smaller :: enum<byte> {}

Expression_Blocks?
    UPDATE: Currently i think these are a bad idea, because return does something else inside these blocks,
        and I could introduce the concept of yield, which would return a value, but I don't think this is necessarily useful.
        The Idea behind expression blocks would be to give more purpose to an unnamed block. E.g.

        The 2 main use cases I have for these are :
            * a short way to write if's and switches
            * Make sure some values are initialized

            The main use cases I can think of are:
                * a short way to write if's and switches
                * Makes sure values are going to be initialized
                * Gives purpose to values (E.g. you know where the values are going to be used)

            Problems:
                * Syntax overlap inside if, switch, while --> Not true with extra syntax, e.g. #{}
                * They may be quite unnecessary, because function can do the same thing
                * ModTree_Code's structure of expressions and statements isn't exactly build for this
                * Would definitly need some experimentation

        fn_call(15, {if condition {yield make_unknown();} yield make_known(condition);});

    found, index: bool, int = {
        
    }

    of 
    expression.index, expression.is_templated = {

    };

    x = {switch color {case .RED: return 5; case .GREEN: return 2;}}
    x = {if a return 4; return 2;}
    z = 32 + {if alive return 17; return -2;}
    min_member: *Struct_Member = 0;
    {
        curr_min: *Struct_Member = members[0];
        loop mem in members {
            if mem.val < curr_min.value curr_min = mem;
        }
        if (curr_min.alive != 0) {
            min_member = curr_min;
        }
    }
    
    // Why could this be useful? Because it gives the code block a distinct purpose, and its impossible to not set the values 
    found, member: bool, *Member = 
    {
        ret_type :: struct {f: bool; mem: *Member};
        loop a in array {
            if condition_met(a) {
                return ret_type{f = true, mem = a};
            }
        }
        return ret_type{f = false, mem = _};
    } 

    // Also some things can be typed rather quickly
    based_num := {if is_based return 69; return 0;};

NOTES:
------
 * Next stuff:
    - Jump to definition fix --> A separate analysis/code generation phase would be nice
    - Code_Completion
 * Improve Language:
    - Compile time code-evaluation
    - Tag-System + Static Analyis
 * Improve Editor:
    - Multiple projects
    - Code-Completion
    - Search and Replace


Metaprogramming features:
-------------------------
 * Templates (Types for Containers, Functions/Values for algorithms and interfaces)
 * Macro System (Iterators, Scope_Break, Variable_Define, Code_Insertion... lots of convenience functions)
 * Defer
 * #if (Conditional Compilation)
 * Currying
 * AST-Manipulation (Compile time Execution)
 * Generating source-code (Compile time Execution)








