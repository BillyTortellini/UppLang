Next features:
--------------
 * Anonymous structs
 * Anonymous enums
 * Struct unpacking syntax
 * Tagged Unions
 * lambdas
 * Inner Functions, inner types (Functions inside other functions, structs/enums/unions inside functions)

 * Constant/Compile-time-known variable syntax
 * Non-Pointer parameters constant
 * Testcases for all new features (Expression-Context, Auto cast, Unions, Switches, Named breaks/continues)
 * Type-Information in language, type_of, Any-Type
 * Rework templates to use comptime values
 * Iteration (Macros?)
 * Generating source code with runtime code execution

Syntax thouhts:
---------------
Some characteristics I want:
    - Compression based length (Often used constructs should be short, others can be long)
    - Easy to remember
    - Same things should look the same, different things should look different
    - Refactoring should be easy
    - Small refactorings should not cause unpredictable errors


Array-Initialization Syntax:
----------------------------
Most languages have arrays default to some value, which is not something I want,
because undefined values are completely fine, and are handled by the static analyzor.

Most of these langauges also use a {}  syntax, which I dislike, because arrays should be [] snytax;
Now how do i differentiate between a type definition []int, and an array expression [. 5, 6, 7]?
Obviously after the [] expression there is no Other type identifier, like [], *, ID

Should 0 sized arrays be a thing?
    I think there are usecases where passing an empty slice to functions may be usefull, which could be initialized with
    int[],
    For now, 0 sized arrays should have a size of 1 byte, so that new [0]int contains a pointer which needs to be freed.
    otherwise, "delete arr;" Must check for 0 pointers, which I maybe dont want

Struct and Array init syntax beeing the same?
    Tuple :: {x: int; y: int;};
    x0 := Tuple{x = 5, y = 17};         // Tuple
    x1 := Tuple[];                      // Tuple array of size 0
    x2 := Tuple[Tuple{x = 5, y = 17}];  // Tuple array of size 1

    // Obvioulsy the auto syntax could also be used here
    x0: Tuple = .{x = 5, y = 17};
    x1: [0]Tuple;                       // Tuple array of size 0                 
    x2: []Tuple = .[];                  // Tuple slice of size 0
    x3: [2]Tuple = .[.{x = 5, y = 17}, .{z = 7, y = 21}];

    Now what about
    x := int[5]; // Is an [1]int, where x[0] = 5;
    x: int[5];   // Parse error

    AST-Parser:
    difference between: int[5]
    and                 x[5] ?
    There is none

    So EXPR_ARRAY_ACCESS may have 0 to multiple children, if the IDENTIFIER is a TYPE, it is an ARRAY initializor,
    if it is an array/slice, it is an array access --> Not differentiable by the parser!



Thought Run-Down:
-----------------
Struct initialization syntax, requiring all members to be set, e.g. 
    Analyser::Workload{x = 15; b = 32; c = true || false;};

Auto struct init syntax:
    workload := .{x = 15; b = 32; c = true||false;};

Anonymous structs:
    x: struct {name: String; value: int;};
    x.name = "Henlo";
    x.value = 5;
    x = .{name = "Henlo"; value = 15;};

Return value may be struct
    find_elem(...) -> struct{found: bool; index: int;}
    return .{found = true; index = 15;};

Struct unpacking syntax
    found, index := find_elem(...);
    f2, _ := find_elem(...);

Lambda support
    x := () {print_string("What");};
    adder := (x: int, y: int) -> int {return x + y;};

Anonymous enum
    tag: enum{RED; GREEN; BLUE};
    tag = .RED;

Choosing enum type
    Something :: enum<int> {}
    Smaller :: enum<byte> {}

Tagged unions using current Enum structure
    Address :: enum
    {
        IPV4 = 
            bytes: [4]byte;
        IPV6 = 
            addr: String;
        NOTHING_MUCH;
        WHATEVER = 
            postal_code: int;
            city_name: String;
            blob: []byte;
    }


    switch addr
    {
    case .IPV4(bytes):
        type_of(v4) == *(Address.IPV4)
        loop byte in v4.bytes 
            print(byte);
    case .IPV6(v6):
        print(v6.addr);
    }

    assert(addr.tag == Address.IPV4);
    addr.tag = .IPV6;
    addr.IPV4.bytes = [byte: 192, 168, 0, 1];

    x: Address.IPV4; // ERROR: This is an enum value, not a type!

    manually creating an enum:
        a: Address;
        a.tag = Address.IPV4;
        a.IPV4.bytes = [byte: 0, 0, 0, 0];
    Does not work with normal initializor
        Address{tag = .IPV4, IPV4.bytes = [byte: 0, 0, 0, 0]} // ERROR: initializor syntax only works on structs, tagged unions require the type
    Initializor with union:
        Color :: union {a: int; b: int; c: int};
        x := Color{a = 5;} // Should work, because we can differentiate based on da ding
    with initializor:
        a: Address = .IPV4{bytes = [byte: 0, 0, 0, 0]};

    




Design Questions:
-----------------
 - Do anonymous structs duck-type?
        No, if this is useful, just define the struct
 - Should the unpacking syntax be allowed for structs as well?
        Yes, why should it not, makes refactoring easier
 - Named argument passing?
        This seems to overlap a lot with struct initilization, since struct initialization IS basically just
        calling a function, but the function exists already for each Struct type
        Maybe I want struct initialization to require naming the arguments, and not for functions

 - With anonymous structs, how are they instanciated?

Design Ideas:
-------------
 - Function parameters are constant, parameters may be passed as pointers if they are too big
 - Functions can only return one value, but it may be an anonymous struct
 - Function return value cannot be dropped, ignore syntax (_ = do_smth();)
 - Unpacking syntax for anonymous structs (x, y = returns_anonymous();)

Design: Multiple returns:
-------------------------
I feel like I want a clear destinction between in, out and in-out parameters of functions
    in: Normal, non-pointer parameters, passed as values
    in-out: Pointer parameters
    out: Return-values

In C you cannot have a clear distinction between these three, because: 
    - You dont want to pass huge structs/unions by pointer  --> Therefore pointer arguments may be in
        In C++ you have constant references, do_smth(const int& smth)
        In Rust/Zig arguments are always constant, and the compiler decides wheter or not they are passed as pointers
    - You cannot have multiple return values                --> Either have a parameter-pointer that is written to, or create and return a struct
        Either support multiple return values, or some tuple types/anonymous structs as returns


Thoughts on pointers:
---------------------
Pointers are essential in Computer programming, and I want them in the language
Null seems to be an issue for a lot of programmers, but this should be handled by the static analyzor
Pointers are used for call by reference,
Pointers are also used to have multiple return values
Pointers are also used to not pass huge structures by value, since this requires copying

If you think about function parameters as either in, out or in_out parameters,
pointers in C basically combine all of those into one feature.
This makes some APIs kinda shitty, because seeing a pointer does not provide the user
information about nullable, if its an in, out or in_out value. 

In Upp I think I want a distinction of these type by having the following:
 - Non-Pointer parameters are constant (So that huge structs can be passed internally by pointer without requiring a copy), 
    although I have to think about constant pointers inside of structs
 - Pointer parameters could in theory be all types of parameters (in, out, in_out), but should only be used for in_out
    which is definitly something that is gonna be required quite often
 - With multiple return values there is no need to use pointers for return values

In C pointers are also used as arrays, with pointer arithmetic being a thing (- and + being defined for pointers)
This also leads to the use of stacked pointers, (char** argv, where argv is actually an array to char*, so []String in my language)
The operations required on pointers in C are:
    - Address-Of    int* xp = &x;
    - Dereference   *xp = *xp + 1;
    - Array-Access  item = xp[2];
    - Arithmetic    item = *(xp + 2);
                    ip   = xp + 2;
                    diff = ip - x;

I would like to be pointers to be as interchangable with values as possible, to do that I want
to pass around the expected_type of expressions 




Syntax what operators are in use:
---------------------------------
    +   ... Addition
    -   ... Subtraction, Unary negate
    *   ... Multiplication/Address Of/Pointer type constructor
    &   ... Dereference
    /   ... Division
    %   ... Modulo
    !   ... Logical not

    <   ... Less 
    >   ... Greater
    <=  ... Less Equals
    >=  ... Greater Equals
    ==  ... Equals
    !=  ... Not Equals

    &&  ... Logical And
    ||  ... Logical Or

    ()  ... Function call/Function definition
    []  ... Array definition/Index operation
    {}  ... Code Block operation
    <>  ... Template argument parenthesis

    "   ... String delimiters
    #   ... Extern declarations (#load)
    .   ... Member access/Auto access
    ;   ... Statement delimiter
    ,   ... List item delimiter

    :   ... Variable definition
    :=  ... Define-Infer
    ::  ... Constant Definition
    ->  ... Function return value

    //  ... Single line comment
    /*  ... Multiline comment start
    */  ... Multiline comment end

Currently unused but plans exist:
    _   ... Unused value in multiple returns
    '   ... Char delimiter (Not implemented yet)
    $   ... Fast Template declaration (Not implemented yet)
    @   ... Annotations
    \   ... String delimiters

Open Characters and normal usage
    ~   ... Bitwise Negate
    ^   ... Bitwise XOR
    &   ... Bitwise And
    |   ... Bitwise Or
    >>  ... Bitshift right
    <<  ... Bitshift left
    ?   ... Ternary Operator
    °   ... Nothing
    




Ideas that just come to mind:
-----------------------------
PrintF Debugging could be replaced with memory visualizer
'Destructors' could be generated with metaprogramming, simple initializors too
Differentiate States and Tags in the language
Should we have compile-time known arguments, are they the same as template args?
Context struct could live in thread-local memory
Auto cast keyword would be nice and easy
Syntax guided editor would be cool I guess
Are stacked pointers a reasonable idea (**int)? Where would i use them
Always cast to appropriate pointer type/take reference, but have special syntax for taking memory/pointer assignments
Automated parameter deduction (Like macros taking names from outer scope)
Automated module/Enum scope finding (node->type == .UNDEFINED)
break continue with identifiers, named scopes, break to named scope
Meta-Programming code modifications may be easy if executed code must be unmodified, and only finaly code is modified
Strings should probably just be byte slices (int + pointer) and be immutable, and we'll just have a String_Builder for output

Code Ideas:
-----------
Type_System should maybe do more, like templates, parameter names, struct names
Symbol template infos add info if symbol is templated
Symbols should keep track of references (Where they are used)
Maybe think about making initializers helpers for expressions/statements?
Const expression evaluation maybe after creation?
Redo template syntax, only allow on functions/structs
Delete IR_Code, just use modtree for translation
Functions may just be compile time known function pointers?
Hardcoded functions should be removed at some point
AST_Node only really needs type and child information for processing, parent and tokenrange could be in another array and multiple structures could exist for this










Next Up:
--------
 * Compile time code execution + Templates
 * Tags and static analyser

Features TODO:
    - Function overhaul: Multiple return values, Named return values
    - Lambdas, Struct/Function definitions inside code-blocks
    - Symbol Tables: Using Modules/Structs, importing Symbol-References into current scope
    - Integer/Float literal overhaul using correct Type depending on Context, 
    - Type introspection (Size, Alignment, Members...), Any-Type
    - Array initializiation syntax
    - Location information (Unique Location, file/line number), Stack-Introspection
    - Tag-System (const-tag + static analyser)
    - Unions and Enums, some type of switch

NOTES:
------
 * Next stuff:
    - Jump to definition fix --> A separate analysis/code generation phase would be nice
    - Code_Completion
    - sizeof required for window creation
    - auto-cast keyword
 * Improve Language:
    - Compile time code-evaluation
    - Enums, structs, unions, switches
    - Tag-System + Static Analyis
 * Improve Editor:
    - Multiple projects
    - Code-Completion
    - Search and Replace


Metaprogramming features:
-------------------------
 * Templates (Types for Containers, Functions/Values for algorithms and interfaces)
 * Macro System (Iterators, Scope_Break, Variable_Define, Code_Insertion... lots of convenience functions)
 * Defer
 * #if (Conditional Compilation)
 * Currying
 * AST-Manipulation (Compile time Execution)
 * Generating source-code (Compile time Execution)


---------------------------
------ ISSUE TRACKER ------
---------------------------

Issues:
-------
 * Templates
    - Structs and functions in templated modules may not use templates
    - Functions created during Template-Analysis should probably be deleted later
    - Globals are currently disabled in a template context
 * Globals
    - Global initializiation order is bad (Depends on dependencies of symbol definitions)

Long-Term Goals:
----------------
 * Debugger
 * Language features (Union/Enum, match, Macros, Compile-Time Execution)
 * Editor features (Search and replace, jump to definition, show context info, refactoring, Code LOD)
 * Maybe implementing Syntax guided Editor
 * Test suite (Now works with the better error system)

More Language features to implement:
------------------------------------
 * Compile time code execution, for types and array indices and stuff
 * Enums, Switch/Match and Unions
 * Tag-System (For constant values, but also other stuff)
   ------- These features are for convenience, but they are not top priority ------
 * Any-Type and Type access (Varargs in this language, maybe use this for printf)
 * New with [] should return a pointer to a slice
 * Array bounds checking would be good
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Lambdas
 * Default variable initialization (Maybe) with 0, although if the value-analyser works correctly, this should be fine
 * Array access with pointers to arrays
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Automatic casting from non-pointer type to pointer in function calls
 * Literal overhaul (What is a float, what isnt...)
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
 * Loop statements, maybe loop over array syntax
 * Break/Continue overhaul (Something like: exit_loop, continue_loop, exit_switch, exit loop_iter)
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Code-Completion using current symbol table
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Compile-Time code execution
  * Static-Analysis in tandum with Tag-System
  * Code-Visualizations in Editor

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Compiler supported Dynamic-Array type
 * Hot-Reloading Code
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Differentiate break_loop, break_switch, maybe break_scope
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language

Code Improvements that should be made (When I have time):
----------------------------------------------------
Use String* for string pooling, not identifiers.
Hashing type signatures for lookup, not array search.

Differentiation between errors and Warnings


Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

At some point the editor should not render at 60 FPS, but rather update when necessary.
Asynchronous Editor-Compiler architecture, lexing/parse/analysing in background when code gets bigger




