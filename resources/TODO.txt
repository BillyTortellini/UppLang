Context Design:
 - Show function signature if above function call
 - Show Symbol type if above identifier

NOTES:
------
 * Next stuff:
    - Show surrounding context (e.g. Error messages in error context, function signature in function call, type of variables...)
    - Jump to definition fix
    - Code_Completion
    - sizeof required for window creation
    - auto-cast keyword
 * Debugger
    - Debug program in Visual studio
    - Output custom PDB files
    - Create own Debugger
 * Improve Language:
    - Compile time code-evaluation
    - Enums, structs, unions, switches
    - Tag-System + Static Analyis
 * Improve Editor:
    - Multiple projects
    - Code-Completion
    - Search and Replace

Calling C-Functions:
--------------------
What sources can functions come from?
    - C Standard Library (Standard headers)
    - Static Libraries (.lib)
    - Dynamic Libraries  (.dll + .lib)
    - Obj-Files
    - Source Files (Need to be compiled into .obj first)

Next Up:
--------
 * Some way to parse header files and convert the functions/structs into UppLang
 * Adding Compilation-Sources inside the program (Libs, Dlls, Source-Files, Standard-Headers)
 * Calling C-Functions from Bytecode (Dyncall)
 * Maybe try to tackle the syntax guided parser?



---------------------------
------ ISSUE TRACKER ------
---------------------------

Issues:
-------
 * Templates
    - Structs and functions in templated modules may not use templates
    - Functions created during Template-Analysis should probably be deleted later
    - Globals are currently disabled in a template context
 * Globals
    - Global initializiation order is bad (Depends on dependencies of symbol definitions)

Long-Term Goals:
----------------
 * Calling C-Functions in Bytecode (Look into dyncall)
 * C-Backend
 * Calling C-Functions in the C-Backend (Maybe with Clang for header file parsing)
 * Debugger
 * More language features
 * More Editor features

More Language features to implement:
------------------------------------
 * Compile time code execution, for types and array indices and stuff
 * Enums, Switch/Match and Unions
 * Tag-System (For constant values, but also other stuff)
   ------- These features are for convenience, but they are not top priority ------
 * Any-Type and Type access (Varargs in this language, maybe use this for printf)
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Lambdas
 * Default variable initialization (Maybe) with 0, although if the value-analyser works correctly, this should be fine
 * Array access with pointers to arrays
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Automatic casting from non-pointer type to pointer in function calls
 * Literal overhaul (What is a float, what isnt...)
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
 * Loop statements, maybe loop over array syntax
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Code-Completion using current symbol table
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Compile-Time code execution
  * Code analysis in tandum with Tag-System
  * Code-Visualizations in Editor

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Compiler supported Dynamic-Array type
 * Hot-Reloading Code
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Differentiate break_loop, break_switch, maybe break_scope
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language

Code Improvements that should be made (When I have time):
----------------------------------------------------
Proper Error Handling in parser and semantic analyser, with error codes and highlighting things in editor.
Also with differentiation between errors and Warnings

Maybe we could also use String* for names, since then I only need to compare string pointers, and not actually strings.
This would also make debuggin so much easier, since we would see the names of things.

Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

At some point the editor should not render at 60 FPS, but rather update when necessary.
