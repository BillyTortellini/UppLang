NOTES:
------
Trying to resolve template arguments when analysing the templates (Without instanciation) will not work,
becase if another templated thing is encountered inside the template, it will fail.

Also, a "simple" switch of all referenced template types in a struct requires also visiting all used types, meaning:
    * Array Sized
    * Array Unsized
    * Pointers
    * Other templated nodes

My current believe is that reanalysing the ast with the correct template parameters is the solution,
which means I need to think about the 
    * Static-Template Analysis
    * Template instanciation (Reanalysis of AST)
    * Template referencing

Some thoughts to consider:
    * Functions created while analysing the template must later be deleted, and may not be referenced by 
        functions that also will be deleted.
    * Modules transfer their template parameters on all members, making some things harder
    * Global variables in Templated-Modules should be treated as such



Current Work Item:
------------------
 * Code-Polymorphism (Template/Generic System)

How to do polymorphism, 
 * Motivation: Containers, Vectors + Matrices
    - Dynamic_Array
    - Hashset

Lets start with the simplest possible Polymorphism:
A module with one Type-Argument

To be fair I want type-arguments and value arguments,
where value arguments need to be compile-time known

Declaration:
module Holder<T: Type>
{
    struct Node
    {
        value: T;
    }
}

A polymorphic Type can only be written or read from, and only T can be written
to it, and only T is received from it

Usage:
node_i32: Holder<i32>::Node;
node_i32.value = 15;
node_bool: Holder<bool>::Node;
node_bool.value = false;

Implementation Plan:
    * Parse templated modules
    * Generate normal Code with this, but maybe flag the functions or something to delete them later
    * See further

How to compile this:
    When i come across the definition, I need to store the module in the symbol table.
    Then I need to analyse the template

    When i come across a usage of this template, I need to 
        * Check if the argument types are finished,
        * Check if the template is already instantiated with these arguments
        * If not, create a workload and a dependency
        * If it is, just lookup the required things in the symbol table

    How to instantiate a template?
        * Splitting Analysis and Code-Gen, after Analysis I would know exactly which functions I would need
        * Generate IR-Code with Template types, and when instanciating swap the IR-Type in the Instructions
        * Reanalyse the AST for each specific Template-Instance

Questions:
    Can polymorphic modules hold other polymorphic modules?
        - Probably, but maybe I should disable this for now





add :: (a: $T, b: T)
{
    res: T;
    res = a + b;
    return res;
}

module Vector<T: Type, dimensions: int>
{
    Vector :: struct {
        coordinates: [dimensions] T;  
    }

    make :: (coords: [dimensions]T) -> Vector {
        Vector result;
        result.coordinates = coords;
        return result;
    }
}

dir := Vector::make([f32: 1.0, 0.0, 3.0]);
up := Vector<f32, 3>::make(0.0);
up.coordinates[0] = 5;

alias Vector<f32, 3> Vector3;
alias Vector3::coordinates[0] x;
alias Vector3::coordinates[0] y;
alias Vector3::coordinates[0] z;

v : Vector3;
v.x = 0;
v.y = 0;
v.z = 0;

module Dynamic_Array<x: int, T: Type>
{
    Dynamic_Array :: struct
    {
        content: []T;
        length
    }

    length        --> 
    size          --> may be confused with bytes
    count         --> does not really imply the size
    element_count --> pretty long

    create :: (initial_capacity: u64) -> Dynamic_Array
    {
        Dynamic_Array result;
        result.content
    }

    destroy :: (arr: Dynamic_Array) {
        delete arr.content;
    }

    operator[] :: (arr: *Dynamic_Array, index: u64) {
        return arr.content[index];
    }
}

// I want to call methods like this:
fill_outs := Dynamic_Array<5, int>::create_empty(32);
Dynamic_Array::destroy<5, int>(fill_outs);

Question:
---------
 * How to reference templated methods?



Long-Term Goals:
----------------
 * Calling C-Functions in Bytecode (Look into dyncall)
 * C-Backend
 * Calling C-Functions in the C-Backend (Maybe with Clang for header file parsing)
 * Debugger
 * More language features
 * More Editor features

More Language features to implement:
------------------------------------
 * Global variable initialization order may be currently quite stupid
 * Compile time code execution, for types and array indices and stuff
 * Enums, Switch/Match and Unions
 * Tag-System (For constant values, but also other stuff)

   ------- These features are for convenience, but they are not top priority ------
 * Any-Type and Type access (Varargs in this language, maybe use this for printf)
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Lambdas
 * Default variable initialization (Maybe) with 0, although if the value-analyser works correctly, this should be fine
 * Array access with pointers to arrays
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Automatic casting from non-pointer type to pointer in function calls
 * Literal overhaul (What is a float, what isnt...)
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
 * Loop statements, maybe loop over array syntax
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Autocompletion using current symbol table
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Compile-Time code evaluation
  * Code analysis in tandum with Tag-System
  * Code-Visualizations in Editor

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Hot-Reloading Code
 * Incremental Builds
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Differentiate break_loop, break_switch
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language

Improvements that should be made (When I have time):
----------------------------------------------------
Proper Error Handling in parser and semantic analyser, with error codes and highlighting things in editor.
Also with differentiation between errors and Warnings

Maybe we could also use String* for names, since then I only need to compare string pointers, and not actually strings.
This would also make debuggin so much easier, since we would see the names of things.

Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

At some point the editor should not render at 60 FPS, but rather update when necessary.

Open Questions:
---------------
How does the syntax for array initialization look like?
    C:
        int x[] = {1, 2, 3, 4, 5}; 
    UppLang:
        x: []int = [1, 2, 3, 4, 5]; // Could this be a potential problem with array access? -> Dont really think so

How do i implement dynamic arrays?
I think it would be nice? if the language would know about these
    x: [..]int;
    new [5]int;
Check out Jonathan Blows streams to check what hes doing

At which stage does metaprogramming/template instances/automatic code generation happen?
I currently almost think that I need another AST-Tree for this, since
I dont think I want to manipulate code on the Intermediate Representation level, due to
the Access things and the expression evaluation things and all this kinda complicated stuff.

This generally concerns me for defer, templates and macros, since doing this on an AST-Level
seems a lot simpler (This isn't confirmed yet). I could also split variable definitions in two things
(Currently define, define-assign, define-infer) and add implicit conversions or return statements when necessary.
Thought: I think templates can ONLY be done on the AST-Level, since the Intermediate Representation already has
exact instructions for binary operators and other stuff.




