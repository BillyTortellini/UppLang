Next features:
--------------
 * Testcases for all new features
 * EDITOR: Yank same as delete up and down
 * Pointer Rework

 * Comptime declaration (Inner functions, inner structs...)
 * Constant/Read-only variables
 * Function overhaul, e.g. Non-Pointer parameters constant, Named parameter values in function calls

 * Literal overhaul (Integers, floats, strings?)

 * Struct unpacking syntax, ignore syntax 
     index, found := find_elem(arr, 2);
     index, _ = find_elem(arr, 3);
     _ = Hashtable~insert();
     union {ipv4: int; ipv5 = _};

 * Conversion function to pointer and back

 * Templates rework (No more templated modules, templated types, templated functions)
 * Interpreter upgrade, call C-Functions, Custom allocator, check memory access
 * Bake with non primitive values, maybe functions
 * Macros and Iteration
 * Generating source code with runtime code execution
 
How about using types in function/lambda definitions
    int_op: Type = (a: int, b: int) -> int;
    add :: bin_op 
    {
        return a + b;
    }

Design Discussion: Pointers/Auto casting/Temporary values
---------------------------------------------------------
Because I don't want to have reference types, I generally want most things to work by pointer.
This includes iteration, operator overloading, member access, and all operations.
E.g.
    x: *int =...;
    y := x + 5; // This should just work

    // Now all things I need for containers:
    arr := Dynamic_Array~create_empty(int, 5);
    arr: Dynamic_Array(int) = Dynamic_Array~create_empty(5);
    defer Dynamic_Array~destroy(arr);
    Dynamic_Array~add(arr, 17);
    Dynamic_Array~add_array(arr, .[1, 2, 3, 4, 5]);

    // These all have to be pointers
    loop x in arr {
        x = x * 2;
    }
    Dynamic_Array~for_each(arr, (x:int) -> {print(x);});
    x := arr[5] + arr[7];
    arr[0] = arr[1] + arr[2];

The problem here is, again, that pointers on their own have operations defined on them,
which do drastically different things compared to the operations executed on non-pointers, which may lead to some errors
The problematic ones are:
    - Equals Comparisons
    - cast to other pointer/cast to u64
    - Assignment statement

The alternative is to not have implicit pointer casting, and relying on the Operators
    ap :=   *a;  // Address-Of  '*'
    &ap =   7;   // Dereference '&' on the left side of assignment is special in general
    x:int = &ap;

If I would go the Java route, I would just not have control of pointers, which would also work
There are obviously cases where I want full pointer control, like custom allocators...

I think I can solve the comparsion and cast problem by introducing new syntax 
e.g. 
    a: *int;
    b: *int;
    value_cmp = a == b; // Compares values, always dereferences
    ptr_cmp = a *== b;  // I cannot use *=, because *= is the multiply_assign operator
    ptr_cmp = a *!= b;

What about double pointers?
    x: int;
    xp: *int;
    xpp: **int;
    app: **int
    cmp := x *== xp;    // ERROR
    cmp := xp *== xpp;  // ERROR
    cmp := app *== xpp; // ERROR
Nullptr?
    xp: *int = null;
    if xp == null // Should error, since we cannot compare a value to a pointer 
    if x *== null // This should work
Double pointer comparisons?
    value := 5;
    p0: *int = *value;
    p1: *int = *value;
    ap: **int = *p0;
    bp: **int = *p1;
    cmp := ap == bp;    // TRUE
    cmp := ap *== bp;   // FALSE, since this is a comparison on the double pointer level and (ap -> p0 != bp -> p1)
    cmp := &ap *== &bp; // TRUE, since this compares the pointers, which both point to value
I also had the idea to have pointer comparison syntax have an argument to show which level of pointer wants to be compared, e.g.
    cmp := ap == bp;      // TRUE,  value 5 == 5
    cmp := ap *== bp;     // TRUE,  because this only looks at pointer level 1  
    cmp := ap **== bp;    // FALSE, because this looks at pointer level 2
    cmp := ap *== value;  // TRUE,  because ap on pointer level 1 actually points to value
    cmp := ap **== value; // ERROR, because trying to take address of a non-const value
    cmp := ap **== p0;    // TRUE,  auto address of can kick in here

To be fair, the second version would probably be more consistent with the idea that pointers are interchangable,
but I think the first version, where implicit casting is just all out disable is better, because it 
doesn't have ugly syntax and probably doesn't cause errors because there is no implicit casting then

Casting: pointers can be cast to u64 and back, to enable pointer arithmetic in this language
    i := x;
    x := cast(u64) i; // This won't error when i is suddenly a pointer, and x will be garbage
    // The same applies in the different direction

    i := 5;
    x := cast_to_raw i;
    val: u64 = 0;
    x := cast_ptr val;

The whole problem of having to specify the pointer level comes from maving multiple pointer levels. (Double/Triple... Pointers) e.g. x: ***int; 
I think if i limit this whole schablam to only one pointer level, I don't need syntax to specify the pointer level.
But I think i would change the syntax for the two operators * and &

Idea: Maybe we can get rid of the dereference operator entirely. If everything is dereferenced automatically this could work
    For this I would need pointer comparisons to have an argument of the pointer level to be compared
    Also cast_to_raw needs to have a pointer argument, since the following may be weird
        x: **int;
        val := cast_raw(u64) x; // 
        addr: u64 = 0;
        val := cast(*int) addr; // Should not work
        val := cast_raw(*int) addr; // Should work
        Theres obviously the cast_to_raw and cast_from_raw
    Also with removing the dereference operator pointer operations (equal, cast) would rely on implicit casting to
    work, and I think this should rather be done with the type system and turning off implicit casting in these cases.
    e.g.
        i := int;
        ip := *i;
        cast_to_raw i;    // ERROR, not a pointer type
        cast_to_raw *i;   // Works
        val := i *== ip;  // ERROR, i not a pointer type
        val := *i *== ip; // WORKS

Is this really a Problem? When would this be a problem?
    Situation #1 Variable change:     Value --> Pointer
        x := 32;
        i: int = 4;
        i = x;
        i = i + 1;

        i: *int;
        i = x;      // This will take the pointer now
        i = i + 1;  // This will error now, because Auto Address-Of won't work on temporary value

    Situation #1 Variable change:     Pointer --> value
        member := get_value_of(account, .TAKE_MONEY);
        // If pointer
        member.counter = counter + 1;
        // If this is not a pointer, this will still work, but the logic won't make sense anymore

So whats the current Solution?
Automatic to/from pointer only works on a single pointer level, multi level pointer won't work like this.
But I still need new syntax for Assignment/Cast/Comparison
 - Comparison 
    i := 5;
    j := 5;
    x: &int = i;    // Auto address of works on one level
    a: &int = &j;   // Address_Of Syntax still valid
    cmp := x == a;  // TRUE  Compares values
    cmp := x &== a; // FALSE Pointer are different
    cmp := x &== i; // TRUE  Auto-address of also works here

    ip: &int = &i;
    ipp: &&int = &ip;
    app: &&int = &a;
    cmp := ipp == a; // ERROR, Cannot compare double pointer to value
    cmp := ipp == ip; // ERROR, Cannot convert double pointer to value
    cmp := ipp &== ip; // ERROR, Types do not implicitly cast to multi pointer
    cmp := ipp &== app; // FALSE, works but in this case they point to different things  

 - Cast
    val: u64 = 128 * 1024;
    ptr: &int = cast(&int)       val; // ERROR, Cannot cast from integer to pointer
    ptr: &int = raw_to_ptr(&int) val; // WORKS
    other: u64 = ptr_to_raw ptr;     // WORKS
    val_p: &u64 = &val;
    ptr: &int = raw_to_ptr(&int) val_p; // WORKS, dereferences val_p and takes it as pointer
    ptr: &int = cast(&int) val_p; // Also works, but this time there is no dereferencing

 - Assignment
    i: int = 5;
    ip: *int;
    ip &= i; // WORKS, takes reference of i 
    ip :&= i; // WORKS, Auto type deduction
    
    ipp: **int &= ip; // ERROR, cannot cast *int to **int
    ipp: **int &= i;  // ERROR, cannot cast int to **int

    x: *int = i;  // ERROR Does not work, pointer is not initialized
    x: *int &= i;
    x &= ip;      // Now x points to the same value as ip
    assert(x &== ip);
    x &= 5;       // Error, cannot take address of temporary value

    remove_node :: (list: &List, node: &Node)
    {
        if (node.next &!= null) {
            node.next.prev &= node.prev;
        }
        if (node.prev &!= null) {
            node.prev.next &= node.next;
        }
    }

 - Implicit casting should also work with single deref
    slice: []int;
    slice_p :&= slice;
    array := int.[1, 2, 3, 4];
    array_p :&= array;

    slice = array;      // Implicit casting slice to array
    slice = array_p;    // Dereference + implicit casting
    slice_p = array;    // Implicit Dereference(slice_p) + cast
    slice_p = array_p;  // Double implicit Dereference
    slice_p &= array_p; // ERROR, After cast the right side is a temporary value, cannot take reference

Problems:
    - What if a function changes to return a pointer? --> The pointer will be turned into a value.
        If it now returns null, there will be nullpointer exceptions, but only at runtime...
        x := calc_value(chungus);
    - What about struct unpacking syntax/multiple return values
        index, found = array_find_min(.[1, 2, 7]);

Some more light-weight solutions:
    * No pointer assign syntax
    * Syntax for pointer compare and 


Operators defined on pointers:
    - Equals Comparisons
    - cast to other pointer/cast to u64
    - Assignment statement

I think the current error I had while designing the things mentioned above is that
I wanted it to be possible to forget that we are dealing with pointers, and just handle
have something like Java where the User wouldn't even know what they are doing.
Which is wrong, although I do want to have some auto-define Syntax, I still want people to know what
values they are dealing with.

Another Idea: Member access and Type access both return a pointer.
    This would align them more with how they work internally, but would deviate from other languages

What about the unary operators?
    - Address_Of  *
    - Dereference &

Usages for the implicit pointer casting
    - Member access on pointers
    - Binary/Unary operations 
    - Assignments

A Solution I thought about:
    - Pointers in a non pointer context will always be handled as values
    - Pointer operators (cast/equals) will get their own syntax, no implicit casting
    - Infer-Declare ':='    no implicit casting
    - Remove :&= because Type-Inference should not have to deal with pointers
    - Unary Pointer OPs no implicit casting
    - What to do with assignments?

How can I handle assignments to pointers?
    i: int = 5;
    x: *int;
    x = i; // What should this do?

Options without new syntax:
1. The right side value always gets casted to the type on the left 
    x = i;     // WORKS, x now points at i
    x = i + 5; // ERROR, cannot take address of temporary value (5 is temporaray)
    i = a[5];  // WORKS
    a[1] = 5;  // ERROR,
    a[1] = i;  // ERROR, cannot write to temporary value (a[1] is temporary)
2. The left side values always gets casted to the type on the right
    x: *int = i;  // RUNTIME_ERROR
    x: *int = *i; // WORKS
    x = i + 1;    // DEPENDS_ON_INIT
    x = a[5];     // Changes pointer
    i = a[5];     // ERROR, left is temp
    a[1] = 5;     // WORKS
    a[1] = i;     // WORKS
    a[1] = x;     // ERROR, write to temporary
3. No implicit casting happens at all
    x: *int = i;  // ERROR
    x = i + 5;    // ERROR
    x = a[5];     // Changes pointer
    i = a[5];     // WORKS
    a[1] = 5;     // ERROR
    a[1] = x;     // ERROR, write to temporary

Options with new syntax:
4. = always writes through the pointer, &= requires a pointer and casts the right side to the given value
    x = i;        // RUNTIME
    x = *i;       // RUNTIME
    x: *int = i;  // ERROR
    x: *int = *i; // ERROR
    x: *int &= i; // WORKS
    x: *int;
    x &= i;       // WORKS
    x &= *i;      // WORKS
    a[5] = 7;     // WORKS
    a[5] &= 7;    // ERROR, write to temporary value (a[5])
    j: int;
    j &= i;       // ERROR, left type is not a pointer
    x = a[5];     // RUNTIME
    ipp: **int = x; // ERROR
    ipp: **int &= *x; // WORKS
Difference &= does not do any casting &= casts right side to left type
    pa: []*int;
    pa[4] &= x;   // When casting right side to left type, this actually produces an error
    pa[4] &= x;   //

    arr: []int;
    parr: []*int;

What about the combination:
    [] overloading dereferences the value returned

    x: &int = i;  // ERROR
    x: &int &= i; // WORKS
    j: int &= i;  // ERROR, cannot &= a non pointer
    pa: []*int = ...;
    pa[0] = 1;    // WRITES value
    pa[0] &= new int;
    
What about:
    = never casts/takes address of something?
    Remove &= operator
    [] overloaded dereferences the pointer value
    Add cast and comparison operator for pointers.
    
    I think this is the goto-strat, because this will result in type conversion errors when converting 
    values to pointers or otherwise, which is the style of defensive programming.






Design Discussion: Constant/Readonly definitions + Constant Propagation
-----------------------------------------------------------------------
Lexicography:
    Constant ... A value known at compile-time. Can be used for optimizations
    Readonly ... A readonly variable that is only initialized once, at declaration. The value of this variable cannot/should not change

I obviously want to have Constant values, because multiple systems build on it, like templates, bake and compile-time execution.
The syntax is also pretty much set in stone right now, with it being quite similar to the variable definition syntax.

Constant Syntax works well because it supports type, functions and variables (And later maybe modules, but we will see about that):
    x :: 5; // Comptime integer
    x: u64: cast 5; 
    x :: #bake(Node) {...; return list.head;};
    x :: () -> int {};
    int_fn :: () -> int;
    x :: struct {}
    x: struct{a: int};

Why would I want a Readonly System in the language?
 * Parameters should not be changable, to allow the compiler to do optimizations with big structs (e.g. pass as pointer)
 * Comptime values should not be changable, because accessing them will at some point result in an error (Readonly pages in C-compilation)
 * Constant propagation would be a lot easier (Readonly variables can be better propagated then normal variables)
 * Readonly variables may be a cleaner solution in Code sometimes

Design questions:
 * Syntax for readonly
 * Pointer interaction with readonly
 * Struct/Union interaction with readonly
 * Should strings be readonly
 * Casting from/to readonly
 * Transitive readonly?

Thoughts:
    // Readonly values:
    x: readonly float = 3.2; // WORKS
    add :: readonly (a: int, b: int) -> int {return a + b;} // ERROR: expected type, not function
    Node :: readonly struct {value: int};                   // WORKS: Node now cannot be changed...

    // Readonly values cannot be changed
    x = 12.0;                      // ERROR, x is readonly
    node: readonly Node;           // ERROR, node is not initialized
    node: readonly Node = .{...};
    node.next &= whatever_node;    // ERROR, member accesses are not allowed on readonly variables
    xp :&= x;                      // WORKS, xp is now a pointer to readonly int
    xp = 5;                        // ERROR, trying to write to readonly value
    ip: *int = 5;                  
    ip &= x;                       // ERROR, cannot cast from *readonly int to *int

    // Pointers to Readonly values can also not be changed
    x: readonly int = 5;
    xp :&= x;
    xp = 7;                        // ERROR, trying to write to readonly int
    i := 5;                         
    xp = i;                        // WORKS,

    // Because readonly usually requires things to be initialized, it can also be added afterwards
    // This will cause problems with the constant propagation, but should still be possible to implement.
    x: int = 5;
    xp :&= x;
    x = x + 7;
    readonly x;
    xp = 7; // Now the readonly value changed to 7, but it still cannot be changed through the x symbol;

    // Constant structs:

    // Pointers/Slices inside structs:
    Node :: struct {
        value: int;
        next: &Node;
    }
    head: Node;
    head = Node.{value = 0; next &= null;};
    head.value += 1;
    readonly head;

    x := head.value + 1;  // WORKS, reading values is not a problem
    head.value += 1;      // ERROR, Everything that is accessed on a const type is now also const 
    x := head.next.value; // WORKS, 





Design:
-------
Constant propagation: Maybe I don't want this at all, and just put this on read_only system
Current testcase: 34 I think

Implementation:
---------------
New Testcases for:
 - Type-Info
 - Any-Type (Casting from/to, size check, data check, type check, during bake/interpreter)
 - Named break/Continue, named blocks

Issues:
-------



Known Bugs:
-----------
 - Sometimes active-switch is not found in switch-case nodes

Strategy:
---------
Big Features before Static-Analysis:
 - Solid language
   * Anonymous and/or Inner definitions
   * Constant + readonly values
   * Function overhaul (Multiple returns, const params, auto-pointer passing, Empty/Ignore-Type _)
   * Literal overhaul
   * Expression blocks?
 - Template rework (Templated values, code execution)
 - Module system improvements with import/using functionality
 - Macros and Iteration
 - Annotation System





---------------------------
------ ISSUE TRACKER ------
---------------------------

Issues:
-------
 * Templates
    - Structs and functions in templated modules may not use templates
    - Functions created during Template-Analysis should probably be deleted later
    - Globals are currently disabled in a template context
 * Globals
    - Global initializiation order is bad (Depends on dependencies of symbol definitions)

Long-Term Goals:
----------------
 * Debugger
 * Language features
 * Editor features (Search and replace, jump to definition, show context info, refactoring, Code LOD)
 * Maybe implementing Syntax guided Editor

More Language features to implement:
------------------------------------
 * Tag-System (For constant values, but also other stuff)
   ------- These features are for convenience, but they are not top priority ------
 * Array bounds checking would be good
 * Macro-System
 * Iterators
 * Location-Information (Filename, line_number...)
 * Using statement
 * Context (Used for memory allocations, useful in Multi-Threading)
 * Array size should be u64, then iteration is more tedious (casting), but with iterators it should be fine
 * Literal overhaul (What is a float, what isnt...)
 * Loop statements, maybe loop over array syntax
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)

Editor features to implement:
-----------------------------
 * Code-Completion using current symbol table
 * Search and Replace
 * CTRL-R for replace word --> I would need Shift-R, since control R is already Redo
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Multi-Window support (Multiple Tabs/Vertical or Horizontal splits, Tabs with shift-Tab)
 * Jump to definition with string search (Maybe Ctrl-F)
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)
 * Tab for indentation/Ctrl-Tab for no indentation
 * Formating with = should remove unneccessary whitespaces/add them where needed, and should ignore comments.
    Actually, this should not be hard even without lexer, since we can count the parenthesis, spaces and other stuff...
 * UTF-8 Support?

Editor-Bugs:
------------
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Currently disabled) (Program crashes)

 Vision for the Programming Language:
 ------------------------------------
  * Compile-Time code execution
  * Static-Analysis in tandum with Tag-System
  * Code-Visualizations in Editor

Ideas that need to be tested:
-----------------------------
 * Implicit parameters in functions, some way of not having to call with all parameters?
 * Using compile-time code-execution for compiler-controll, metaprogramming and static analysis
 * Strong Code-Analysis (Analysing all possible values), with Warning System and user input
 * Tag-System (For const, but also other information, generated by user and compiler)
 * Visualizations for Code, better navigation, module system
 * Non-Destructive Code-Editing for larger modules

 * Tag for not used anymore for variables
 * Compiler supported Dynamic-Array type
 * Hot-Reloading Code
 * Stack-Analysis for Debug information (Or others? E.g. logging)
 * Differentiate break_loop, break_switch, maybe break_scope
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language

Code Improvements that should be made (When I have time):
----------------------------------------------------
Use String* for string pooling, not identifiers.
Hashing type signatures for lookup, not array search.

Differentiation between errors and Warnings


Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

At some point the editor should not render at 60 FPS, but rather update when necessary.
Asynchronous Editor-Compiler architecture, lexing/parse/analysing in background when code gets bigger





----------------------------
------ RANTS/THOUGHTS ------
----------------------------

Syntax Design-Principles:
-------------------------
Some characteristics I want:
    - Compression based length (Often used constructs should be short, others can be long)
    - Easy to remember
    - Similar things should look similarly, different things should look different
    - Refactoring should be easy
    - Small refactorings should not cause unpredictable errors

Rant: On Serializability
------------------------
In C and C++, the program does not have access to type-information, meaning that something like automatic serialization is not possible inside the language.
    You could still do this by writing custom tools, which parse the code again (e.g. with clang) to get this type-information
    and create files containing serialization code (Was done by Valve Physics Engine Programmers), but this is -very- tedious and error-prone.
Even if this works, you cannot serialize all data, mainly because of pointers/references, which is the reason you cannot just memcopy data for serialization.
To solve this, some changes to C/C++ are required:
    - Dynamically Allocated arrays must have a size member (e.g. Slices in Upp have a size)
    - Void* may not be used inside these structures (You don't have any type information about that), which is solved with the Any-Type
A problem that still exists is that function pointers will not work/require special serialization effort.

Design Questions:
-----------------
 - Do anonymous structs duck-type?
        No, if this is useful, just define the struct
 - Should the unpacking syntax be allowed for structs as well?
        Yes, why should it not, makes refactoring easier
 - Named argument passing?
        This seems to overlap a lot with struct initilization, since struct initialization IS basically just
        calling a function, but the function exists already for each Struct type
        Maybe I want struct initialization to require naming the arguments, and not for functions
        Not exactly the same, since Union initialization is 
 - With anonymous structs, how are they instanciated?

Design Ideas:
-------------
 - Function parameters are constant, parameters may be passed as pointers if they are too big
 - Functions can only return one value, but it may be an anonymous struct
 - Function return value cannot be dropped, ignore syntax (_ = do_smth();)
 - Unpacking syntax for anonymous structs (x, y = returns_anonymous();)

Design: Multiple returns:
-------------------------
I feel like I want a clear destinction between in, out and in-out parameters of functions
    in: Normal, non-pointer parameters, passed as values
    in-out: Pointer parameters
    out: Return-values

In C you cannot have a clear distinction between these three, because: 
    - You dont want to pass huge structs/unions by pointer  --> Therefore pointer arguments may be in
        In C++ you have constant references, do_smth(const int& smth)
        In Rust/Zig arguments are always constant, and the compiler decides wheter or not they are passed as pointers
    - You cannot have multiple return values                --> Either have a parameter-pointer that is written to, or create and return a struct
        Either support multiple return values, or some tuple types/anonymous structs as returns


Thoughts on pointers:
---------------------
UPDATE:
Pointers acting exactly the same as values is, I think, a great idea. The only problem we have are
situation where a pointer operation could also be used instead of a value operation. 
The question I am having is wheter or not I want to have special syntax to solve this problem. 
The current operations that accept both pointers and values are:
    - Equals-Comparisons (== and !=)
    - Cast to u64 (cast(u64))

Pointers are essential in Computer programming, and I want them in the language
Null seems to be an issue for a lot of programmers, but this should be handled by the static analyzor
Pointers are used for call by reference,
Pointers are also used to have multiple return values
Pointers are also used to not pass huge structures by value, since this requires copying

If you think about function parameters as either in, out or in_out parameters,
pointers in C basically combine all of those into one feature.
This makes some APIs kinda shitty, because seeing a pointer does not provide the user
information about nullable, if its an in, out or in_out value. 

In Upp I think I want a distinction of these type by having the following:
 - Non-Pointer parameters are constant (So that huge structs can be passed internally by pointer without requiring a copy), 
    although I have to think about constant pointers inside of structs
 - Pointer parameters could in theory be all types of parameters (in, out, in_out), but should only be used for in_out
    which is definitly something that is gonna be required quite often
 - With multiple return values there is no need to use pointers for return values

In C pointers are also used as arrays, with pointer arithmetic being a thing (- and + being defined for pointers)
This also leads to the use of stacked pointers, (char** argv, where argv is actually an array to char*, so []String in my language)
The operations required on pointers in C are:
    - Address-Of    int* xp = &x;
    - Dereference   *xp = *xp + 1;
    - Array-Access  item = xp[2];
    - Arithmetic    item = *(xp + 2);
                    ip   = xp + 2;
                    diff = ip - x;

I would like to be pointers to be as interchangable with values as possible, to do that I want
to pass around the expected_type of expressions 




Syntax what operators are in use:
---------------------------------
    +   ... Addition
    -   ... Subtraction, Unary negate
    *   ... Multiplication/Address Of/Pointer type constructor
    &   ... Dereference
    /   ... Division
    %   ... Modulo
    !   ... Logical not

    <   ... Less 
    >   ... Greater
    <=  ... Less Equals
    >=  ... Greater Equals
    ==  ... Equals
    !=  ... Not Equals

    &&  ... Logical And
    ||  ... Logical Or

    ()  ... Function call/Function definition
    []  ... Array definition/Index operation
    {}  ... Code Block operation
    <>  ... Template argument parenthesis

    "   ... String delimiters
    #   ... Extern declarations (#load)
    .   ... Member access/Auto access
    ;   ... Statement delimiter
    ,   ... List item delimiter

    :   ... Variable definition
    :=  ... Define-Infer
    ::  ... Constant Definition
    ->  ... Function return value

    //  ... Single line comment
    /*  ... Multiline comment start
    */  ... Multiline comment end

Currently unused but plans exist:
    _   ... Unused value in multiple returns
    '   ... Char delimiter (Not implemented yet)
    $   ... Fast Template declaration (Not implemented yet)
    @   ... Annotations
    \   ... String delimiters

Open Characters and normal usage
    ~   ... Bitwise Negate
    ^   ... Bitwise XOR
    &   ... Bitwise And
    |   ... Bitwise Or
    >>  ... Bitshift right
    <<  ... Bitshift left
    ?   ... Ternary Operator
    °   ... Nothing
    




Ideas that just come to mind:
-----------------------------
PrintF Debugging could be replaced with memory visualizer
'Destructors' could be generated with metaprogramming, simple initializors too
Advanced initializers could also be generated with metaprogramming and Annotations
Differentiate States and Tags in the language
Should we have compile-time known arguments, are they the same as template args?
Context struct could live in thread-local memory
Syntax guided editor would be cool I guess
Are stacked pointers a reasonable idea (**int)? Where would i use them
Automated parameter deduction (Like macros taking names from outer scope)
Meta-Programming code modifications may be easy if executed code must be unmodified, and only finaly code is modified
Strings should probably just be byte slices (int + pointer) and be immutable, and we'll just have a String_Builder for output

Code Ideas:
-----------
Type_System should maybe do more, like templates, parameter names, struct names
Symbol template infos add info if symbol is templated
Maybe think about making initializers helpers for expressions/statements?
Const expression evaluation maybe after creation?
Redo template syntax, only allow on functions/structs
Delete IR_Code, just use modtree for translation
Functions may just be compile time known function pointers?
Hardcoded functions should be removed at some point
AST_Node only really needs type and child information for processing, parent and tokenrange could be in another array and multiple structures could exist for this
ModTree and IR_Code Structure is probably not final, but well see when we know more
Workload-Structure may be easier if we could analyse the dependencies beforehand -->
    Maybe implement pre-analysis step, so that Workloads dont need Pauses/Wait for dependencies
Custom allocator for Bytecode-Interpreter, check pointers if they are in range, have custom boolean
    which can be toggled to indicate that C-Functions may be called
Initialize all variables to zero in Bytecode

Thought Run-Down:
-----------------
Maybe remove single statement blocks, e.g. if (bool) return false;
Just replace these with if (cond) {return false;}

Anonymous structs:
    x: struct {name: String; value: int;};
    x.name = "Henlo";
    x.value = 5;
    x = .{name = "Henlo"; value = 15;};

Return value may be struct
    find_elem(...) -> struct{found: bool; index: int;}
    return .{found = true; index = 15;};

Values may be left explicitly uninitialized
    .{found = _, index = 15};

Struct unpacking syntax
    found, index := find_elem(...);
    f2, _ := find_elem(...);

Return values must be explicitly ignored:
    _ = hashtable_add_element(whatever...);

Lambda support
    x := () {print_string("What");};
    adder := (x: int, y: int) -> int {return x + y;};

Choosing enum type
    Something :: enum<int> {}
    Smaller :: enum<byte> {}

Expression_Blocks?
    UPDATE: Currently i think these are a bad idea, because return does something else inside these blocks,
        and I could introduce the concept of yield, which would return a value, but I don't think this is necessarily useful.
        The Idea behind expression blocks would be to give more purpose to an unnamed block. E.g.

        The 2 main use cases I have for these are :
            * a short way to write if's and switches
            * Make sure some values are initialized

            The main use cases I can think of are:
                * a short way to write if's and switches
                * Makes sure values are going to be initialized
                * Gives purpose to values (E.g. you know where the values are going to be used)

            Problems:
                * Syntax overlap inside if, switch, while --> Not true with extra syntax, e.g. #{}
                * They may be quite unnecessary, because function can do the same thing
                * ModTree_Code's structure of expressions and statements isn't exactly build for this
                * Would definitly need some experimentation

        fn_call(15, {if condition {yield make_unknown();} yield make_known(condition);});

    found, index: bool, int = {
        
    }

    of 
    expression.index, expression.is_templated = {

    };

    x = {switch color {case .RED: return 5; case .GREEN: return 2;}}
    x = {if a return 4; return 2;}
    z = 32 + {if alive return 17; return -2;}
    min_member: *Struct_Member = 0;
    {
        curr_min: *Struct_Member = members[0];
        loop mem in members {
            if mem.val < curr_min.value curr_min = mem;
        }
        if (curr_min.alive != 0) {
            min_member = curr_min;
        }
    }
    
    // Why could this be useful? Because it gives the code block a distinct purpose, and its impossible to not set the values 
    found, member: bool, *Member = 
    {
        ret_type :: struct {f: bool; mem: *Member};
        loop a in array {
            if condition_met(a) {
                return ret_type{f = true, mem = a};
            }
        }
        return ret_type{f = false, mem = _};
    } 

    // Also some things can be typed rather quickly
    based_num := {if is_based return 69; return 0;};

NOTES:
------
 * Next stuff:
    - Jump to definition fix --> A separate analysis/code generation phase would be nice
    - Code_Completion
 * Improve Language:
    - Compile time code-evaluation
    - Tag-System + Static Analyis
 * Improve Editor:
    - Multiple projects
    - Code-Completion
    - Search and Replace


Metaprogramming features:
-------------------------
 * Templates (Types for Containers, Functions/Values for algorithms and interfaces)
 * Macro System (Iterators, Scope_Break, Variable_Define, Code_Insertion... lots of convenience functions)
 * Defer
 * #if (Conditional Compilation)
 * Currying
 * AST-Manipulation (Compile time Execution)
 * Generating source-code (Compile time Execution)








