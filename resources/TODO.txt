Current Work Item:
------------------
 * Structs
 * Syntax for new/delete

Structs need syntax for creation, I guess it would be
    Struct      <--     Identifier :: struct { Members }
    Members     <--     Member {Member}
    Member      <--     Identifier: Type;

What code is affected:
    - Parser                        ... Need parsing of the AST
    - Semantic Analyser             ... Need new analysis, No empty struct definitions -> Warning
    - Intermediate_Code_Geneartor   ... Member access currently only works on .size and .data, this needs to change
                                        Also i think its currently assumed that all root-children are functions

Long-Term Goals:
----------------
 * More language features
 * C-Backend
 * Debugger
 * Calling C-Functions
 * More Editor features

More Language features to implement:
------------------------------------
 * Structs
 * Syntax for new/delete
   ------- Before this I should implement some editor features (Linter at least) -------
 * Default variable initialization (0)
 * Primitive Types (And calculating with them, e.g. u8, u16, u32...) INFO: Array bounds check should then be done with u32, not i32, so negative values are detected
 * Casting (Float/Int implicit, from smaller to bigger implicit?, reinterpret cast thing)
 * Global Data
 * Strings
 * Syntax for fixed array initialization [int :: 1, 2, 3, 4, 5]
   ------- Before this I should fix all the editor bugs ------
 * Function return value overhaul: Multiple return values or no return value should be possible
 * Function pointers, lambdas
 * Defer statement
 * Tagged Unions
 * Location-Information (Filename, line_number...)
 * Any-Type and Type access (Varargs in this language)
 * Code-Polymorphism (Template/Generic System)
 * Modules
 * Constant values (Maybe as the first iteration of the tag-system)
 * Variation for simple Dynamic dispatch  (Like interfaces in OO..., similar to dynamic in Rust)
 * Iterators
 * Macro-System
 * Context (Used for memory allocations, useful in Multi-Threading)

Editor features to implement:
-----------------------------
 * Linter (Auto formating)
 * Autocompletion (Question if I want it to be just a text featuer, or using the ast)
 * Visual Mode/Blockmode (Multicursor)/Visual Line
 * Undo/Redo Tree History
 * Command recording (@ stuff with vim, altough this could maybe be done better)

Editor-Bugs:
------------
 * Repeat last search does not differentiate 'f'/'t'/forward backward
 * 'r' is buggy on line end, and on empty lines
 * Undo-Redo cursor position still sucks a little (Hint: Save positions after/before command)
 * Non ASCII chars destroy some motions (Program crashes)
 * Alt-Gr spamming still cancels commands (win32 nonsense)
 * % does not jump on empty parenthesis () {}
 * O does not work on first line
 * dd with numbers seems to not take the last number
 * put with 'dd'ed lines is also a bit weird
 * CTRL-W in insert mode deletes all newlines too
 * When the text file is empty, syntax highlighting crashes

Ideas that need to be tested:
-----------------------------
 * Redirect debug output to application window
 * Error-Handling with the most recent build of the language
 * Using compile-time code-execution for metaprogramming and other stuff
 * Code-Analysis with data-value semantics (Tag System)
 * Hot-Code Reloading
 * Stack-Analysis for Debug information (Or others?)

Improvements that should be made (When I have time):
----------------------------------------------------
Replace all namespace ENUM types with enum class things.

Create a Compiler struct that holds all the relevant stuff
    * Lexer
    * Parser
    * Analyser
    * IM-Generator
    * Bytecode-Generator
    * Bytecode-Interpreter
And just call the Compiler from the text editor --> This has to be done eventually,
but then I need to rewrite how things are access through the compiler.

Maybe we could also use String* for names, since then I only need to compare string pointers, and not actually strings.
This would also make debuggin so much easier, since we would see the names of things.

Semantic Analyse should keep the node_index of the first definition of each symbol (Symbol table), 
currently only true for functions. 
Intermediate Code should keep positional information, so should the bytecode (Will be necessary for the debugger)
Improved Parser-Error handling. (Function-Parsing Error handling should check each following line if it is a function)

Open Questions:
---------------
Should I change the function syntax? 
From
    main :: (x:int, y: int) -> int {}
To
    main(x: int, y: int) -> int {}
    main(x: int) -> 
Maybe, but i dont think it makes a big difference, and it wont work with structs or other fixed data
I actually quite like it, so I will probably do it 
The problem here is that function calls will look very similar to function definitions
    main(15);
    main(x: int){}
But function calls can only be done in expressions, so parsing this should be no problem!
I dont actually think i want this, the more i think about it. It does not make a difference and it may not make sense

How does the syntax for array initialization look like?
    C:
        int x[] = {1, 2, 3, 4, 5}; 
    UppLang:
        x: []int = [1, 2, 3, 4, 5]; // Could this be a potential problem with array access? -> Dont really think so

How do i implement dynamic arrays?
I think it would be really nice if the language would know about these
    x: [..]int;
    new [5]int;
Check out Jonathan Blows streams to check what hes doing




