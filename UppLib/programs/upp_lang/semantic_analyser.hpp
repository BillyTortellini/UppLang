#pragma once

#include "../../datastructures/string.hpp"
#include "../../datastructures/dynamic_array.hpp"
#include "../../datastructures/hashtable.hpp"
#include "../../datastructures/stack_allocator.hpp"
#include "../../datastructures/list.hpp"

#include "type_system.hpp"
#include "compiler_misc.hpp"

struct Type_Signature;
struct Symbol;
struct Symbol_Table;
struct Compiler;
struct ModTree_Function;
struct Upp_Constant;
enum class Constant_Status;
struct Semantic_Error;
struct Error_Information;
struct Expression_Info;
struct Analysis_Pass;

struct Workload_Definition;
struct Workload_Base;
struct Workload_Import_Resolve;

struct Function_Progress;
struct Struct_Progress;
struct Bake_Progress;
struct Module_Progress;

namespace Parser
{
    enum class Section;
}

namespace AST
{
    struct Node;
    struct Code_Block;
    struct Path_Lookup;
}



// Polymorphism
enum class Comptime_Result_Type
{
    AVAILABLE,
    UNAVAILABLE, // The expression is comptime, but not evaluable due to the context (E.g. errors, Polymorphic parameters)
    NOT_COMPTIME,
};

struct Comptime_Result
{
    Comptime_Result_Type type;
    void* data;
    Type_Signature* data_type;
};

struct Polymorphic_Value
{
    bool is_not_set; // E.g. during base analysis
    Upp_Constant constant;
};

struct Polymorphic_Base;
struct Polymorphic_Instance
{
    Polymorphic_Base* base;
    int instance_index;
    Array<Polymorphic_Value> parameter_values;
    Function_Progress* progress;

    // Information for stopping recursion
    int instances_generated;
    Polymorphic_Instance* root_instance; // If this instance was not create from a base, but from another instance, the pointer to this instance
};

struct Polymorphic_Base
{
    Function_Progress* progress;
    int parameter_count;
    Dynamic_Array<Polymorphic_Instance*> instances;
};



// Modtree TODO: Rename this into something more sensible, like Upp-Function
struct ModTree_Function
{
    Type_Signature* signature;
    Symbol* symbol; // May be 0 (e.g. anonymous functions)
    Symbol_Table* parameter_table; 
    Workload_Base* code_workload; // Workload that generated the semantic info required for code-gen (Either Function-body or Bake-Analysis)
    Function_Progress* progress; // May be null if the function was generated by a Bake

    // Infos
    bool contains_errors; // NOTE: contains_errors (No errors in this function) != is_runnable (This + all called functions are runnable)
    bool is_runnable;
    Dynamic_Array<ModTree_Function*> called_from;
    Dynamic_Array<ModTree_Function*> calls;
};

struct ModTree_Global
{
    Type_Signature* type;
    int index;

    bool has_initial_value;
    AST::Expression* init_expr;
    Workload_Definition* definition_workload; // For code generation
};

struct ModTree_Program
{
    Dynamic_Array<ModTree_Function*> functions;
    Dynamic_Array<ModTree_Global*> globals;
    ModTree_Function* main_function;
};




// WORKLOADS
enum class Dependency_Type
{
    NORMAL,
    MEMBER_IN_MEMORY,
    MEMBER_REFERENCE,
};

enum class Analysis_Workload_Type
{
    EVENT, // Empty workload, which can have dependencies and dependents

    MODULE_ANALYSIS, // This is basically just symbol discovery
    USING_RESOLVE,   // 

    FUNCTION_HEADER,
    FUNCTION_PARAMETER,
    FUNCTION_BODY,
    FUNCTION_CLUSTER_COMPILE,

    STRUCT_ANALYSIS,
    STRUCT_REACHABLE_RESOLVE,

    BAKE_ANALYSIS,
    BAKE_EXECUTION,

    DEFINITION,
};

struct Workload_Base
{
    Analysis_Workload_Type type;
    bool is_finished;
    bool was_started;
    Fiber_Pool_Handle fiber_handle;
    Symbol_Table* parent_table; // Active table at time of workload creation

    // Information required to be consistent during workload switches
    // Note: These members are automatically set in functions like analyse_expression, analyse_statement...
    //       Also note that some of these may not be set depending on the workload type
    ModTree_Function* current_function;
    Expression_Info* current_expression;
    Array<Polymorphic_Value> current_polymorphic_values; // NOTE: Non-owning 'pointer' to array
    bool statement_reachable;
    Symbol_Table* current_symbol_table;
    Analysis_Pass* current_pass;
    Dynamic_Array<AST::Code_Block*> block_stack; // NOTE: This is here because it is required by Bake-Analysis and code-block, also for statement blocks...

    // Dependencies
    List<Workload_Base*> dependencies;
    List<Workload_Base*> dependents;

    // Note: Clustering is required for Workloads where cyclic dependencies on the same workload-type are allowed,
    //       like recursive functions or structs containing pointers to themselves
    // FUTURE: Maybe we can rework clustering to be a little more genera and easier to use
    Workload_Base* cluster;
    Dynamic_Array<Workload_Base*> reachable_clusters;
};

struct Workload_Event
{
    Workload_Base base;
    const char* description;
};

struct Workload_Module_Analysis
{
    Workload_Base base;
    Module_Progress* progress;
    AST::Module* module_node;
    Symbol_Table* symbol_table;
    Workload_Import_Resolve* last_import_workload;
    Workload_Module_Analysis* parent_analysis;
};

struct Workload_Import_Resolve
{
    Workload_Base base;
    AST::Import* import_node;
    Symbol* symbol; // May be 0 if its an import
    Symbol* alias_for_symbol; // May be 0 if its an import
};

struct Workload_Function_Header;
struct Workload_Function_Parameter
{
    Workload_Base base;
    Workload_Function_Header* header;
    AST::Parameter* param_node;
    Symbol* symbol;
    Type_Signature* base_type; // Type of parameter in function/polymorphic base
    int execution_order_index;
};

struct Workload_Function_Header
{
    Workload_Base base;
    Function_Progress* progress;
    AST::Expression* function_node;
    Dynamic_Array<Workload_Function_Parameter*> parameter_order;
};

struct Workload_Function_Body
{
    Workload_Base base;
    Function_Progress* progress;
    AST::Code_Block* body_node;
};

struct Workload_Function_Cluster_Compile
{
    Workload_Base base;
    Function_Progress* progress;
    Dynamic_Array<ModTree_Function*> functions;
};

struct Workload_Struct_Analysis
{
    Workload_Base base;
    Struct_Progress* progress;
    AST::Expression* struct_node;
    Dependency_Type dependency_type;
};

struct Workload_Struct_Reachable_Resolve
{
    Workload_Base base;
    Struct_Progress* progress;
    Dynamic_Array<Type_Signature*> struct_types;
    Dynamic_Array<Type_Signature*> unfinished_array_types;
};

struct Workload_Definition
{
    Workload_Base base;
    Symbol* symbol;
    AST::Definition* definition_node;
};

struct Workload_Bake_Analysis
{
    Workload_Base base;
    Bake_Progress* progress;
    AST::Expression* bake_node;
};

struct Workload_Bake_Execution
{
    Workload_Base base;
    Bake_Progress* progress;
    AST::Expression* bake_node;
};



// ANALYSIS_PROGRESS
struct Struct_Progress
{
    Type_Signature* struct_type;

    Workload_Struct_Analysis* analysis_workload;
    Workload_Struct_Reachable_Resolve* reachable_resolve_workload;
};

struct Bake_Progress
{
    ModTree_Function* bake_function;
    Comptime_Result result;

    Workload_Bake_Analysis* analysis_workload;
    Workload_Bake_Execution* execute_workload;
};

struct Function_Progress
{
    ModTree_Function* function;

    Workload_Function_Header* header_workload;
    Workload_Function_Body* body_workload;
    Workload_Function_Cluster_Compile* compile_workload;

    // If we are dealing with a polymorphic instance, this value is not 0
    Polymorphic_Instance* poly_instance;
};

struct Module_Progress
{
    Workload_Module_Analysis* module_analysis;
    Workload_Event* event_symbol_table_ready; // After all using workloads have ended
    Symbol* symbol; // May be 0 if root
};




// WORKLOAD EXECUTER
struct Workload_Pair
{
    Workload_Base* workload;
    Workload_Base* depends_on;
};

struct Dependency_Information
{
    List_Node<Workload_Base*>* dependency_node;
    List_Node<Workload_Base*>* dependent_node;
    // Information for cyclic resolve
    bool only_symbol_read_dependency;
    Dynamic_Array<AST::Symbol_Lookup*> symbol_lookups;
};

struct Workload_Executer
{
    Dynamic_Array<Workload_Base*> all_workloads;
    Dynamic_Array<Workload_Base*> runnable_workloads;
    Dynamic_Array<Workload_Base*> finished_workloads;
    bool progress_was_made;

    Hashtable<Workload_Pair, Dependency_Information> workload_dependencies;

    // Allocations
    Stack_Allocator progress_allocator;
};

void workload_executer_resolve();
Module_Progress* workload_executer_add_module_discovery(AST::Module* module, bool is_root_module);



// Analysis Information
enum class Info_Cast_Type
{
    INTEGERS, // Implicit to bigger
    FLOATS, // Implicit to bigger
    FLOAT_TO_INT,
    INT_TO_FLOAT, // Implicit
    POINTERS, // Implicit from/to void*
    POINTER_TO_U64,
    U64_TO_POINTER,
    ENUM_TO_INT,
    INT_TO_ENUM,
    ARRAY_TO_SLICE, // Implicit
    TO_ANY,
    FROM_ANY,

    NO_CAST, // No cast required
    INVALID, // No cast can create the desired result, but we still handle it as a cast
};

enum class Expression_Context_Type
{
    UNKNOWN,             // Type is not known
    AUTO_DEREFERENCE,    // Type is not known, but we want pointer level 0 
    SPECIFIC_TYPE,       // Type is known, pointer level items + implicit casting enabled
};

struct Expression_Context
{
    Expression_Context_Type type;
    Type_Signature* signature;
};

enum class Expression_Result_Type
{
    VALUE,
    TYPE,
    FUNCTION,
    HARDCODED_FUNCTION,
    POLYMORPHIC_FUNCTION,
    CONSTANT,
};

struct Argument_Info
{
    bool valid; // Used in both polymorphic functions/named parameters and struct initializer
    int argument_index; // For named arguments/parameters this gives the according parameter index
    Struct_Member member; // For struct initializer
};

struct Expression_Info
{
    // All types in "options" union are before the expression context has been applied
    Expression_Result_Type result_type;
    union
    {
        Type_Signature* value_type;
        Type_Signature* type;
        ModTree_Function* function;
        struct {
            // Note: Analysis of polymorphic functions takes 2 steps, so the base is the result of the first one, and the instance the second one
            Polymorphic_Base* base;
            Polymorphic_Instance* instance;  // If the function was instanciated from parent, otherwise 0 (base instance)
        } polymorphic;
        Hardcoded_Type hardcoded;
        Symbol_Table* module_table;
        Upp_Constant constant;
        int argument_index;
    } options;

    bool contains_errors; // If this expression contains any errors (Not recursive), currently only used for comptime-calculation
    union {
        Info_Cast_Type cast_type;
        Type_Signature* function_call_signature; // Somewhat usefull when not all arguments in a call are used (polymorphic funcitons, later named/default args)
    } specifics;

    Expression_Context context; // Maybe I don't even want to store the context
    struct { // Info for code-gen
        int deref_count;
        bool take_address_of;
        Info_Cast_Type cast;
        Type_Signature* after_cast_type;
    } context_ops;
};

enum class Control_Flow
{
    SEQUENTIAL, // One sequential path exists, but there may be paths that aren't sequential
    STOPS,      // Execution never goes further than the given statement, but there may be paths that return
    RETURNS,    // All possible code path return
};

struct Statement_Info
{
    Control_Flow flow;
    struct {
        AST::Code_Block* block; // Continue/break
    } specifics;
};

struct Code_Block_Info
{
    Symbol_Table* symbol_table;
    Control_Flow flow;
    bool control_flow_locked;
};

struct Case_Info
{
    int is_valid;
    int case_value; // Currently we only switch over enums/ints
};

struct Parameter_Info {
    Symbol* symbol;
};

struct Definition_Info {
    Symbol* symbol;
};

struct Symbol_Lookup_Info {
    Symbol* symbol; // Resolved symbol
};

struct Path_Lookup_Info {
    Symbol* symbol; // Resolved symbol
};

struct Module_Info {
    Symbol_Table* symbol_table;
};

union Analysis_Info
{
    Expression_Info info_expr;
    Statement_Info info_stat;
    Code_Block_Info info_block;
    Case_Info info_case;
    Argument_Info arg_info;
    Parameter_Info param_info;
    Definition_Info definition_info;
    Symbol_Lookup_Info symbol_lookup_info;
    Path_Lookup_Info path_info;
    Module_Info module_info;
};

enum class Info_Query
{
    CREATE,
    READ_NOT_NULL,  // Value must be there, otherwise panic
    TRY_READ,       // May return 0
    CREATE_IF_NULL, // Always returns info (Creates one if not existing)
};

Expression_Info* pass_get_node_info(Analysis_Pass* pass, AST::Expression* node, Info_Query query);
Case_Info* pass_get_node_info(Analysis_Pass* pass, AST::Switch_Case* node, Info_Query query);
Argument_Info* pass_get_node_info(Analysis_Pass* pass, AST::Argument* node, Info_Query query);
Statement_Info* pass_get_node_info(Analysis_Pass* pass, AST::Statement* node, Info_Query query);
Code_Block_Info* pass_get_node_info(Analysis_Pass* pass, AST::Code_Block* node, Info_Query query);
Symbol_Lookup_Info* pass_get_node_info(Analysis_Pass* pass, AST::Symbol_Lookup* node, Info_Query query);
Definition_Info* pass_get_node_info(Analysis_Pass* pass, AST::Definition* node, Info_Query query);
Parameter_Info* pass_get_node_info(Analysis_Pass* pass, AST::Parameter* node, Info_Query query);
Path_Lookup_Info* pass_get_node_info(Analysis_Pass* pass, AST::Path_Lookup* node, Info_Query query);
Module_Info* pass_get_node_info(Analysis_Pass* pass, AST::Module* node, Info_Query query);

Type_Signature* expression_info_get_type(Expression_Info* info);



// HELPERS
struct Predefined_Symbols
{
    // Symbols for primitive types
    Symbol* type_bool;
    Symbol* type_int;
    Symbol* type_float;
    Symbol* type_u8;
    Symbol* type_u16;
    Symbol* type_u32;
    Symbol* type_u64;
    Symbol* type_i8;
    Symbol* type_i16;
    Symbol* type_i32;
    Symbol* type_i64;
    Symbol* type_f32;
    Symbol* type_f64;
    Symbol* type_byte;
    Symbol* type_void;

    // Symbols for 'compiler' provided structs
    Symbol* type_string;
    Symbol* type_type;
    Symbol* type_type_information;
    Symbol* type_any;
    Symbol* type_empty;

    // Symbols for hardcoded types
    Symbol* hardcoded_type_info;
    Symbol* hardcoded_type_of;
    Symbol* hardcoded_assert;
    Symbol* hardcoded_print_bool;
    Symbol* hardcoded_print_i32;
    Symbol* hardcoded_print_f32;
    Symbol* hardcoded_print_string;
    Symbol* hardcoded_print_line;
    Symbol* hardcoded_read_i32;
    Symbol* hardcoded_read_f32;
    Symbol* hardcoded_read_bool;
    Symbol* hardcoded_random_i32;

    // Error-Symbol (Used when Symbol-Reads cannot be resolved, e.g. symbol not defined)
    Symbol* error_symbol;
};

// I currently need this so that a workload can analyse the same node multiple times
struct Analysis_Pass 
{
    Workload_Base* origin_workload;
};

struct AST_Info_Key
{
    Analysis_Pass* pass;
    AST::Node* base;
};

struct Node_Passes
{
    Dynamic_Array<Analysis_Pass*> passes;
    AST::Node* base;
};



// ANALYSER
struct Semantic_Analyser
{
    // Result
    Dynamic_Array<Semantic_Error> errors;
    ModTree_Program* program;
    Hashtable<AST::Node*, Node_Passes> ast_to_pass_mapping;
    Hashtable<AST_Info_Key, Analysis_Info*> ast_to_info_mapping;

    // Stuff required for analysis
    Symbol_Table* root_symbol_table;
    Dynamic_Array<Symbol_Table*> allocated_symbol_tables;
    Dynamic_Array<Symbol*> allocated_symbols;
    Hashset<Symbol_Table*> symbol_lookup_visited;

    Module_Progress* root_module;
    Dynamic_Array<Analysis_Pass*> allocated_passes;

    Predefined_Symbols predefined_symbols;
    Workload_Executer* workload_executer;
    Dynamic_Array<Polymorphic_Base*> polymorphic_functions;
    Stack_Allocator allocator_values;
    Workload_Base* current_workload;

    ModTree_Global* global_type_informations;
};

Semantic_Analyser* semantic_analyser_initialize();
void semantic_analyser_destroy();
void semantic_analyser_reset();
void semantic_analyser_finish();

Type_Signature* hardcoded_type_to_signature(Hardcoded_Type type);



// ERRORS
enum class Semantic_Error_Type
{
    TEMPLATE_ARGUMENTS_INVALID_COUNT,
    TEMPLATE_ARGUMENTS_NOT_ON_TEMPLATE,
    TEMPLATE_ARGUMENTS_REQUIRED,

    CYCLIC_DEPENDENCY_DETECTED,

    EXTERN_HEADER_DOES_NOT_CONTAIN_SYMBOL, // Error_node = is identifier_node
    EXTERN_HEADER_PARSING_FAILED, // Error_node = EXTERN_HEADER_IMPORT

    EXPECTED_TYPE,
    EXPECTED_VALUE,
    EXPECTED_CALLABLE,
    INVALID_EXPRESSION_TYPE,

    INVALID_TYPE,
    INVALID_TYPE_VOID_USAGE,
    INVALID_TYPE_FUNCTION_CALL, // Expression
    INVALID_TYPE_FUNCTION_IMPORT_EXPECTED_FUNCTION_POINTER,
    INVALID_TYPE_ARGUMENT,
    INVALID_TYPE_ARRAY_ACCESS, // x: int; x[5];
    INVALID_TYPE_ARRAY_ACCESS_INDEX, // x: int; x[5];
    INVALID_TYPE_ARRAY_ALLOCATION_SIZE, // new [false]int;
    INVALID_TYPE_ARRAY_SIZE, // x: [bool]int;
    INVALID_TYPE_ON_MEMBER_ACCESS,
    INVALID_TYPE_IF_CONDITION,
    INVALID_TYPE_WHILE_CONDITION,
    INVALID_TYPE_UNARY_OPERATOR,
    INVALID_TYPE_BINARY_OPERATOR,
    INVALID_TYPE_ASSIGNMENT,
    INVALID_TYPE_RETURN,
    INVALID_TYPE_DELETE,
    INVALID_TYPE_ENUM_VALUE,
    INVALID_TYPE_EXPECTED_POINTER,
    INVALID_TYPE_CAST_RAW_REQUIRES_POINTER,
    INVALID_TYPE_CAST_PTR_REQUIRES_U64,
    INVALID_TYPE_CAST_PTR_DESTINATION_MUST_BE_PTR,

    INVALID_TYPE_COMPTIME_DEFINITION,
    COMPTIME_DEFINITION_MUST_BE_COMPTIME_KNOWN,
    COMPTIME_DEFINITION_MUST_BE_INFERED,
    COMPTIME_DEFINITION_REQUIRES_INITAL_VALUE,

    CONSTANT_POOL_ERROR,

    MODULE_NOT_VALID_IN_THIS_CONTEXT,

    ENUM_VALUE_MUST_BE_COMPILE_TIME_KNOWN,
    ENUM_VALUE_MUST_BE_UNIQUE,
    ENUM_MEMBER_NAME_MUST_BE_UNIQUE,
    ENUM_DOES_NOT_CONTAIN_THIS_MEMBER,

    SWITCH_REQUIRES_ENUM,
    SWITCH_CASES_MUST_BE_COMPTIME_KNOWN,
    SWITCH_MUST_HANDLE_ALL_CASES,
    SWITCH_MUST_NOT_BE_EMPTY,
    SWITCH_ONLY_ONE_DEFAULT_ALLOWED,
    SWITCH_CASE_TYPE_INVALID,
    SWITCH_CASE_MUST_BE_UNIQUE,

    VARIABLE_NOT_DEFINED_YET,

    SYMBOL_EXPECTED_MODUL_IN_IDENTIFIER_PATH,
    SYMBOL_EXPECTED_TYPE_ON_TYPE_IDENTIFIER,
    SYMBOL_ALREADY_DEFINED,
    SYMBOL_MODULE_INVALID,

    SYMBOL_TABLE_UNRESOLVED_SYMBOL,
    SYMBOL_TABLE_SYMBOL_ALREADY_DEFINED,
    SYMBOL_TABLE_MODULE_ALREADY_DEFINED,

    FUNCTION_CALL_ARGUMENT_SIZE_MISMATCH,
    AUTO_MEMBER_KNOWN_CONTEXT_IS_REQUIRED,
    AUTO_MEMBER_MUST_BE_IN_ENUM_CONTEXT,
    AUTO_CAST_KNOWN_CONTEXT_IS_REQUIRED,

    EXPRESSION_INVALID_CAST,
    EXPRESSION_MEMBER_NOT_FOUND,
    EXPRESSION_ADDRESS_MUST_NOT_BE_OF_TEMPORARY_RESULT,
    CANNOT_TAKE_POINTER_OF_FUNCTION,
    EXPRESSION_BINARY_OP_TYPES_MUST_MATCH,
    EXPRESSION_STATEMENT_MUST_BE_FUNCTION_CALL,

    BAKE_FUNCTION_MUST_NOT_REFERENCE_GLOBALS,
    BAKE_FUNCTION_DID_NOT_SUCCEED,
    BAKE_BLOCK_RETURN_MUST_NOT_BE_EMPTY,
    BAKE_BLOCK_RETURN_TYPE_DIFFERS_FROM_PREVIOUS_RETURN,

    EXPRESSION_CONTAINS_INVALID_TYPE_HANDLE,
    TYPE_NOT_KNOWN_AT_COMPILE_TIME,
    EXPRESSION_IS_NOT_A_TYPE,

    COMPTIME_ARGUMENT_NOT_KNOWN_AT_COMPTIME,

    MAIN_CANNOT_BE_TEMPLATED,
    MAIN_NOT_DEFINED,
    MAIN_UNEXPECTED_SIGNATURE,
    MAIN_CANNOT_BE_CALLED,
    MAIN_MUST_BE_FUNCTION,

    BREAK_NOT_INSIDE_LOOP_OR_SWITCH,
    BREAK_LABLE_NOT_FOUND,
    CONTINUE_NOT_INSIDE_LOOP,
    CONTINUE_LABEL_NOT_FOUND,
    CONTINUE_REQUIRES_LOOP_BLOCK,
    LABEL_ALREADY_IN_USE,

    ARRAY_SIZE_NOT_COMPILE_TIME_KNOWN,
    ARRAY_SIZE_MUST_BE_GREATER_ZERO,

    ARRAY_INITIALIZER_REQUIRES_TYPE_SYMBOL,
    ARRAY_INITIALIZER_INVALID_TYPE,
    ARRAY_AUTO_INITIALIZER_COULD_NOT_DETERMINE_TYPE,

    STRUCT_INITIALIZER_REQUIRES_TYPE_SYMBOL,
    STRUCT_INITIALIZER_MEMBERS_MISSING,
    STRUCT_INITIALIZER_MEMBER_INITIALIZED_TWICE,
    STRUCT_INITIALIZER_TYPE_MUST_BE_STRUCT,
    STRUCT_INITIALIZER_MEMBER_DOES_NOT_EXIST,
    STRUCT_INITIALIZER_INVALID_MEMBER_TYPE,
    STRUCT_INITIALIZER_CAN_ONLY_SET_ONE_UNION_MEMBER,
    STRUCT_INITIALIZER_CANNOT_SET_UNION_TAG,
    AUTO_STRUCT_INITIALIZER_COULD_NOT_DETERMINE_TYPE,

    STRUCT_MUST_CONTAIN_MEMBER,
    STRUCT_MEMBER_ALREADY_DEFINED,
    STRUCT_MEMBER_REQUIRES_TYPE,
    STRUCT_MEMBER_MUST_NOT_HAVE_VALUE,

    MISSING_FEATURE_NAMED_ARGUMENTS,

    OTHERS_TYPE_MEMBER_ACCESS_MUST_BE_ENUM,
    OTHERS_MEMBER_ACCESS_INVALID_ON_FUNCTION,
    OTHERS_WHILE_ONLY_RUNS_ONCE,
    OTHERS_WHILE_ALWAYS_RETURNS,
    OTHERS_WHILE_NEVER_STOPS,
    OTHERS_STATEMENT_UNREACHABLE,
    OTHERS_DEFER_NO_RETURNS_ALLOWED,
    OTHERS_MISSING_RETURN_STATEMENT,
    OTHERS_UNFINISHED_WORKLOAD_FUNCTION_HEADER,
    OTHERS_UNFINISHED_WORKLOAD_CODE_BLOCK,
    OTHERS_UNFINISHED_WORKLOAD_TYPE_SIZE,
    OTHERS_CANNOT_TAKE_ADDRESS_OF_MAIN,
    OTHERS_ASSIGNMENT_REQUIRES_MEMORY_ADDRESS,
    OTHERS_RETURN_EXPECTED_NO_VALUE,
    OTHERS_CANNOT_TAKE_ADDRESS_OF_HARDCODED_FUNCTION,
    OTHERS_COULD_NOT_LOAD_FILE,

    MISSING_FEATURE_TEMPLATED_GLOBALS,
    MISSING_FEATURE_NESTED_TEMPLATED_MODULES,
    MISSING_FEATURE_EXTERN_IMPORT_IN_TEMPLATED_MODULES,
    MISSING_FEATURE_EXTERN_GLOBAL_IMPORT,
    MISSING_FEATURE,
    MISSING_FEATURE_NESTED_DEFERS
};

enum class Error_Information_Type
{
    ARGUMENT_COUNT,
    INVALID_MEMBER,
    ID,
    SYMBOL,
    EXIT_CODE,

    GIVEN_TYPE,
    EXPECTED_TYPE,
    FUNCTION_TYPE,
    BINARY_OP_TYPES,
    CYCLE_WORKLOAD,

    EXPRESSION_RESULT_TYPE,
    CONSTANT_STATUS,
    EXTRA_TEXT,
};

struct Error_Information
{
    Error_Information_Type type;
    union
    {
        struct {
            int expected;
            int given;
        } invalid_argument_count;
        const char* extra_text;
        String* id;
        Symbol* symbol;
        Exit_Code exit_code;
        Type_Signature* type;
        struct {
            Type_Signature* struct_signature;
            String* member_id;
        } invalid_member;
        Workload_Base* cycle_workload;
        struct {
            Type_Signature* left_type;
            Type_Signature* right_type;
        } binary_op_types;
        Expression_Result_Type expression_type;
        Constant_Status constant_status;
    } options;
};

struct Semantic_Error
{
    Semantic_Error_Type type;
    AST::Node* error_node;
    Dynamic_Array<Error_Information> information;
};


void semantic_analyser_add_error_info(Error_Information info);
Error_Information error_information_make_text(const char* text);
void semantic_analyser_log_error(Semantic_Error_Type type, AST::Node* node);
void semantic_analyser_set_error_flag(bool error_due_to_unknown);
void semantic_error_append_to_string(Semantic_Error e, String* string);
Parser::Section semantic_error_get_section(Semantic_Error e);
