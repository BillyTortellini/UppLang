#pragma once

#include "../../datastructures/string.hpp"
#include "../../datastructures/dynamic_array.hpp"
#include "../../datastructures/hashtable.hpp"
#include "../../datastructures/stack_allocator.hpp"
#include "../../datastructures/list.hpp"

#include "type_system.hpp"
#include "compiler_misc.hpp"
#include "parser.hpp"
#include "constant_pool.hpp"
#include "symbol_table.hpp"

struct Symbol;
struct Symbol_Table;
struct Compiler;
struct ModTree_Function;
struct Semantic_Error;
struct Error_Information;
struct Expression_Info;
struct Analysis_Pass;

struct Workload_Definition;
struct Workload_Base;
struct Workload_Import_Resolve;
struct Workload_Structure_Polymorphic;
struct Workload_Structure_Body;

struct Function_Progress;
struct Bake_Progress;
struct Module_Progress;
struct Datatype_Template_Parameter;

namespace Parser
{
    enum class Section;
}

namespace AST
{
    struct Node;
    struct Code_Block;
    struct Path_Lookup;
    struct Expression;
}



// Modtree TODO: Rename this into something more sensible, like Upp-Function
struct ModTree_Function
{
    Datatype_Function* signature;
    Symbol* symbol; // May be 0 (e.g. anonymous functions, bake)
    Symbol_Table* parameter_table; 
    Workload_Base* code_workload; // Workload that generated the semantic info required for code-gen (Either Function-body or Bake-Analysis)
    Function_Progress* progress; // May be null if the function was generated by a Bake
    i64 function_index_plus_one; // Index in functions array + 1 (So that 0 can be used as null pointer)

    // Infos
    bool contains_errors; // NOTE: contains_errors (No errors in this function) != is_runnable (This + all called functions are runnable)
    bool is_runnable;
    Dynamic_Array<ModTree_Function*> called_from;
    Dynamic_Array<ModTree_Function*> calls;
};

struct ModTree_Global
{
    Datatype* type;
    int index;

    bool has_initial_value;
    AST::Expression* init_expr;
    Workload_Definition* definition_workload; // For code generation

    void* memory; // Used by interpreter
};

struct ModTree_Program
{
    Dynamic_Array<ModTree_Function*> functions;
    Dynamic_Array<ModTree_Global*> globals;
    ModTree_Function* main_function;
};



// WORKLOADS
enum class Polymorphic_Analysis_Type
{
    NON_POLYMORPHIC,
    POLYMORPHIC_BASE,
    POLYMORPHIC_INSTANCE
};

struct Polymorphic_Value
{
    bool only_datatype_known; // In base analysis/during instanciation only the datatype may be known
    union {
        Datatype* type;
        Upp_Constant value;
    } options;
};

enum class Analysis_Workload_Type
{
    EVENT, // Empty workload, which can have dependencies and dependents

    MODULE_ANALYSIS, // This is basically just symbol discovery
    IMPORT_RESOLVE,  
    OPERATOR_CONTEXT_CHANGE,

    FUNCTION_HEADER,
    FUNCTION_BODY,
    FUNCTION_CLUSTER_COMPILE,

    STRUCT_POLYMORPHIC,
    STRUCT_BODY,

    BAKE_ANALYSIS,
    BAKE_EXECUTION,

    DEFINITION,
};

struct Workload_Base
{
    Analysis_Workload_Type type;
    bool is_finished;
    bool was_started;
    Fiber_Pool_Handle fiber_handle;

    // Information required to be consistent during workload switches
    // Note: These members are automatically set in functions like analyse_expression, analyse_statement...
    //       Also note that some of these may not be set depending on the workload type
    ModTree_Function* current_function;
    Expression_Info* current_expression;
    bool statement_reachable;
    Symbol_Table* current_symbol_table;
    Symbol_Access_Level symbol_access_level;
    Analysis_Pass* current_pass;
    Dynamic_Array<AST::Code_Block*> block_stack; // NOTE: This is here because it is required by Bake-Analysis and code-block, also for statement blocks...

    int real_error_count;
    int errors_due_to_unknown_count;
    bool ignore_unknown_errors;

    // Note: All workloads need information when accessing polymorphic values. The main two use-cases are:
    //        * Re-analysing the header during poly-instanciation of functions
    //        * Accessing polymorphic-symbols inside child-workloads (Anonymous functions/anonymous structs, bake)
    Array<Polymorphic_Value> polymorphic_values; // May be null, in which case we shouldn't be able to access polymorphics at all
    int polymorphic_instanciation_depth; 

    // Dependencies
    List<Workload_Base*> dependencies;
    List<Workload_Base*> dependents;

    // Note: Clustering is required for Workloads where cyclic dependencies on the same workload-type are allowed,
    //       like recursive functions or structs containing pointers to themselves
    Workload_Base* cluster;
    Dynamic_Array<Workload_Base*> reachable_clusters;
};

struct Workload_Event
{
    Workload_Base base;
    const char* description;
};

struct Workload_Module_Analysis;
struct Workload_Operator_Context_Change
{
    Workload_Base base;
    Workload_Module_Analysis* parent_workload;
    AST::Module* module_node;
    Operator_Context* context;
};

struct Workload_Module_Analysis
{
    Workload_Base base;
    Module_Progress* progress;
    AST::Module* module_node;
    Symbol_Table* symbol_table;

    Workload_Import_Resolve* last_import_workload;
    Workload_Module_Analysis* parent_analysis;
};

struct Workload_Import_Resolve
{
    Workload_Base base;
    AST::Import* import_node;
    Symbol* symbol; // May be 0 if its an import
    Symbol* alias_for_symbol; // May be 0 if its an import
};

struct Workload_Function_Header
{
    Workload_Base base;
    Function_Progress* progress;
    AST::Expression* function_node;
};

struct Workload_Function_Body
{
    Workload_Base base;
    Function_Progress* progress;
    AST::Code_Block* body_node;
};

struct Workload_Function_Cluster_Compile
{
    Workload_Base base;
    Function_Progress* progress;
    Dynamic_Array<ModTree_Function*> functions;
};

struct Workload_Definition
{
    Workload_Base base;
    Symbol* symbol;
    bool is_comptime;
    AST::Expression* value_node;
    AST::Expression* type_node;
};

struct Workload_Bake_Analysis
{
    Workload_Base base;
    Bake_Progress* progress;
    AST::Expression* bake_node;
};

struct Workload_Bake_Execution
{
    Workload_Base base;
    Bake_Progress* progress;
    AST::Expression* bake_node;
};



// Polymorphism
struct Polymorphic_Parameter
{
    Function_Parameter infos;

    // Polymorphic infos
    bool is_comptime;
    union {
        int value_access_index; // For comptime parameters
        int index_in_non_polymorphic_signature; // For normal parameters
    } options;
    Dynamic_Array<int> depends_on;
    Dynamic_Array<int> dependees;
    int dependency_count;
};

struct Implicit_Parameter_Infos
{
    int defined_in_parameter_index;
    AST::Expression* expression;
    String* id;
    Datatype_Template_Parameter* template_parameter;
};

struct Polymorphic_Base_Info;
struct Polymorphic_Instance_Info
{
    Polymorphic_Base_Info* base_info;
    Array<Polymorphic_Value> instance_parameter_values;

    bool is_function_instance;
    union {
        Function_Progress* function_instance;
        Workload_Structure_Body* struct_instance;
    } options;
};

struct Polymorphic_Base_Info
{
    String* name; // Either struct or function name

    // Parameters: List of parameters with comptime parameters + if return type exisits, it's the last value here
    Array<Polymorphic_Parameter> parameters;
    // Order in which arguments need to be evaluated in for instanciation
    Dynamic_Array<int> parameter_analysis_order; 
    Dynamic_Array<Implicit_Parameter_Infos> implicit_parameter_infos;
    Array<Polymorphic_Value> base_parameter_values; // During base analysis only types of parameters are known
    Dynamic_Array<Polymorphic_Instance_Info> instances;

    // For convenience
    int return_type_index; // I guess -1 if no return type?
    AST::Expression* return_type_node;
    Dynamic_Array<AST::Parameter*> parameter_nodes;
    Symbol_Table* symbol_table;
};



// Structures
struct Workload_Structure_Body
{
    Workload_Base base;

    Datatype_Struct* struct_type;
    AST::Expression* struct_node;

    Polymorphic_Analysis_Type polymorphic_type;
    union {
        Workload_Structure_Polymorphic* base;
        struct {
            Workload_Structure_Polymorphic* parent;
            int instance_index;
        } instance;
    } polymorphic;
};

struct Workload_Structure_Polymorphic
{
    Workload_Base base;
    Workload_Structure_Body* body_workload;

    Polymorphic_Base_Info info;
};



// ANALYSIS_PROGRESS

// This type only exist so we can have a pointer to a polymorphic function base (Which is always the member in Function_Progress)
struct Polymorphic_Function_Base
{
    Polymorphic_Base_Info base_info;
};

struct Function_Progress
{
    ModTree_Function* function;

    Workload_Function_Header* header_workload; // Points to base header workload if it's an instance
    Workload_Function_Body* body_workload;
    Workload_Function_Cluster_Compile* compile_workload;

    Polymorphic_Analysis_Type type;
    union {
        Polymorphic_Function_Base base;
        Polymorphic_Function_Base* instance_base;
    } polymorphic;
};

struct Bake_Progress
{
    ModTree_Function* bake_function;
    Datatype* result_type;
    Optional<Upp_Constant> result;

    Workload_Bake_Analysis* analysis_workload;
    Workload_Bake_Execution* execute_workload;
};

struct Module_Progress
{
    Workload_Module_Analysis* module_analysis;
    Workload_Event* event_symbol_table_ready; // After all using workloads have ended
    Symbol* symbol; // May be 0 if root
};




// WORKLOAD EXECUTER
struct Workload_Pair
{
    Workload_Base* workload;
    Workload_Base* depends_on;
};

struct Dependency_Failure_Info
{
    bool* fail_indicator;
    AST::Symbol_Lookup* error_report_node;
};

struct Dependency_Information
{
    List_Node<Workload_Base*>* dependency_node;
    List_Node<Workload_Base*>* dependent_node;
    // Information for cyclic resolve
    bool can_be_broken;
    Dynamic_Array<Dependency_Failure_Info> fail_indicators;
};

struct Workload_Executer
{
    Dynamic_Array<Workload_Base*> all_workloads;
    Dynamic_Array<Workload_Base*> runnable_workloads;
    Dynamic_Array<Workload_Base*> finished_workloads;
    bool progress_was_made;

    Hashtable<Workload_Pair, Dependency_Information> workload_dependencies;
};

void workload_executer_resolve();
Module_Progress* workload_executer_add_module_discovery(AST::Module* module, bool is_root_module);



// Analysis Information
enum class Expression_Context_Type
{
    UNKNOWN,                // Type is not known
    AUTO_DEREFERENCE,       // Type is not known, but we want pointer level 0, e.g. a value (e.g. member-access, slice-access, ...)
    SPECIFIC_TYPE_EXPECTED, // Type is known, pointer level items + implicit casting enabled
};

struct Expression_Context
{
    Expression_Context_Type type;
    bool unknown_due_to_error; // If true the context is unknown because an error occured, otherwise there is no info
    struct {
        Datatype* type;
        Cast_Mode cast_mode;
    } expected_type;
};

enum class Cast_Type
{
    INTEGERS,
    FLOATS,
    FLOAT_TO_INT,
    INT_TO_FLOAT,
    POINTERS,
    POINTER_TO_U64,
    U64_TO_POINTER,
    ENUM_TO_INT,
    INT_TO_ENUM,
    ARRAY_TO_SLICE, 
    TO_ANY,
    FROM_ANY,
    POINTER_NULL_CHECK,
    CUSTOM_CAST,

    NO_CAST, // No cast needed, source-type == destination-type
    UNKNOWN, // Either source or destination type are/contain error/unknown type
    INVALID, // Cast is not valid
};

// The dereferences/address_of is applied before the cast
struct Expression_Cast_Info
{
    Datatype* initial_type;
    Datatype* result_type;
    bool initial_value_is_temporary;
    bool result_value_is_temporary;
    bool check_subtype_tag_on_value;

    int deref_count; // May be negative to indicate take-address of
    Cast_Type cast_type;

    union {
        ModTree_Function* custom_cast_function;
        const char* error_msg; // Null, except if the cast is invalid
    } options;
};

enum class Member_Access_Type
{
    STRUCT_MEMBER_ACCESS, // Includes subtype and tag access
    STRUCT_POLYMORHPIC_PARAMETER_ACCESS,
    DOT_CALL_AS_MEMBER,
    STRUCT_SUBTYPE,
};

enum class Expression_Result_Type
{
    VALUE,
    TYPE,
    CONSTANT,
    FUNCTION,
    DOT_CALL,
    HARDCODED_FUNCTION,
    POLYMORPHIC_FUNCTION,
    POLYMORPHIC_STRUCT,
    NOTHING, // Functions returning void
};

struct Expression_Info
{
    // All types in "options" union are before the expression context has been applied
    Expression_Result_Type result_type;
    union
    {
        Datatype* value_type;
        Datatype* type;
        Workload_Structure_Polymorphic* polymorphic_struct;
        ModTree_Function* function;
        struct {
            Polymorphic_Function_Base* base;
            ModTree_Function* instance_fn;
        } polymorphic_function;
        struct {
            AST::Expression* first_argument;
            bool is_polymorphic;
            union {
                ModTree_Function* function;
                struct {
                    Polymorphic_Function_Base* base;
                    ModTree_Function* instance;
                } polymorphic;
            } options;
        } dot_call;
        Hardcoded_Type hardcoded;
        Symbol_Table* module_table;
        Upp_Constant constant;
    } options;

    bool contains_errors; // If this expression contains any errors (Not recursive), currently only used for comptime-calculation (And code editor I guess?)
    union {
        Datatype_Function* function_call_signature; // Used by code-generation for accessing default values
        Function_Parameter* implicit_parameter;
        struct {
            Member_Access_Type type;
            union {
                struct {
                    Workload_Structure_Body* struct_workload;
                    int index; // Either normal member index, or polymorphic parameter index
                } poly_access;
                Struct_Member member;
                ModTree_Function* dot_call_function;
            } options;
        } member_access;
        struct {
            ModTree_Function* function; // Is null if it's a primitive overload (e.g. not overloaded)
            bool switch_left_and_right;
        } overload;
    } specifics;

    Expression_Context context; // Maybe I don't even want to store the context
    Expression_Cast_Info cast_info;
};

enum class Argument_State
{
    NOT_ANALYSED,
    CAST_MISSING,
    ANALYSED
};

struct Argument_Info
{
    Argument_State state;
    AST::Expression* expression;
    Datatype* argument_type; // Type of analysed expression
    bool is_temporary_value;
    Optional<String*> argument_name;
    int parameter_index; // -1 Indicates that argument hasn't been matched yet or a failure to match
    bool reanalyse_param_type_flag;
    bool ignore_during_code_generation; // If polymorphic_function, the argument shouldn't generate code during code-generation
};

enum class Context_Change_Info_Type
{
    IGNORE_ON_IMPORT, 
    CAST_OPTION,
    CUSTOM_OPERATOR
};

struct Context_Change_Info
{
    Context_Change_Info_Type type;
    union {
        Cast_Option cast_option;
        Custom_Operator_Key key; // Note: On polymorphic cast/commutative binop multiple keys have to be inserted!
    } options;
    bool has_commutative_version;
};

enum class Control_Flow
{
    SEQUENTIAL, // One sequential path exists, but there may be paths that aren't sequential
    STOPS,      // Execution never goes further than the given statement, but there may be paths that return
    RETURNS,    // All possible code path return
};

struct Statement_Info
{
    Control_Flow flow;
    struct {
        AST::Code_Block* block; // Continue/break
        bool is_struct_split; // Definition or assignment
        struct {
            ModTree_Function* function;
            bool switch_arguments;
        } overload; // Binop assignments (function is null if no overload)
        struct {
            Symbol_Table* symbol_table;
            Symbol* loop_variable_symbol;
        } for_loop;
        struct {
            Symbol_Table* symbol_table;
            Symbol* loop_variable_symbol;
            Symbol* index_variable_symbol; // May be null

            bool is_custom_op;
            struct {
                ModTree_Function* fn_create;
                ModTree_Function* fn_has_next;
                ModTree_Function* fn_next;
                ModTree_Function* fn_get_value;
                int has_next_pointer_diff;
                int next_pointer_diff;
                int get_value_pointer_diff;
            } custom_op;
        } foreach_loop;
    } specifics;
};

struct Code_Block_Info
{
    Symbol_Table* symbol_table;
    Control_Flow flow;
    bool control_flow_locked;
};

struct Case_Info
{
    int is_valid;
    int case_value; // Currently we only switch over enums/ints
};

struct Parameter_Info {
    Symbol* symbol;
};

struct Definition_Symbol_Info {
    Symbol* symbol;
};

struct Symbol_Lookup_Info {
    Symbol* symbol; // Resolved symbol
};

struct Path_Lookup_Info {
    Symbol* symbol; // Resolved symbol
};

struct Module_Info {
    Symbol_Table* symbol_table;
};

union Analysis_Info
{
    Expression_Info info_expr;
    Statement_Info info_stat;
    Code_Block_Info info_block;
    Case_Info info_case;
    Argument_Info arg_info;
    Parameter_Info param_info;
    Definition_Symbol_Info definition_symbol_info;
    Symbol_Lookup_Info symbol_lookup_info;
    Path_Lookup_Info path_info;
    Module_Info module_info;
    Context_Change_Info context_info;
};

enum class Info_Query
{
    CREATE,
    READ_NOT_NULL,  // Value must be there, otherwise panic
    TRY_READ,       // May return 0
    CREATE_IF_NULL, // Always returns info (Creates one if not existing)
};

Expression_Info* pass_get_node_info(Analysis_Pass* pass, AST::Expression* node, Info_Query query);
Case_Info* pass_get_node_info(Analysis_Pass* pass, AST::Switch_Case* node, Info_Query query);
Argument_Info* pass_get_node_info(Analysis_Pass* pass, AST::Argument* node, Info_Query query);
Statement_Info* pass_get_node_info(Analysis_Pass* pass, AST::Statement* node, Info_Query query);
Code_Block_Info* pass_get_node_info(Analysis_Pass* pass, AST::Code_Block* node, Info_Query query);
Symbol_Lookup_Info* pass_get_node_info(Analysis_Pass* pass, AST::Symbol_Lookup* node, Info_Query query);
Definition_Symbol_Info* pass_get_node_info(Analysis_Pass* pass, AST::Definition_Symbol* node, Info_Query query);
Parameter_Info* pass_get_node_info(Analysis_Pass* pass, AST::Parameter* node, Info_Query query);
Path_Lookup_Info* pass_get_node_info(Analysis_Pass* pass, AST::Path_Lookup* node, Info_Query query);
Module_Info* pass_get_node_info(Analysis_Pass* pass, AST::Module* node, Info_Query query);
Context_Change_Info* pass_get_node_info(Analysis_Pass* pass, AST::Context_Change* node, Info_Query query);

Datatype* expression_info_get_type(Expression_Info* info, bool before_context_is_applied);



// HELPERS
struct Predefined_Symbols
{
    // Symbols for primitive types
    Symbol* type_bool;
    Symbol* type_int;
    Symbol* type_float;
    Symbol* type_u8;
    Symbol* type_u16;
    Symbol* type_u32;
    Symbol* type_u64;
    Symbol* type_i8;
    Symbol* type_i16;
    Symbol* type_i32;
    Symbol* type_i64;
    Symbol* type_f32;
    Symbol* type_f64;
    Symbol* type_byte;

    // Symbols for 'compiler' provided structs
    Symbol* type_type;
    Symbol* type_type_information;
    Symbol* type_any;
    Symbol* type_empty;
    Symbol* type_void_pointer;

    // Symbols for hardcoded types
    Symbol* hardcoded_type_info;
    Symbol* hardcoded_type_of;
    Symbol* hardcoded_assert;
    Symbol* hardcoded_print_bool;
    Symbol* hardcoded_print_i32;
    Symbol* hardcoded_print_f32;
    Symbol* hardcoded_print_string;
    Symbol* hardcoded_print_line;
    Symbol* hardcoded_read_i32;
    Symbol* hardcoded_read_f32;
    Symbol* hardcoded_read_bool;
    Symbol* hardcoded_random_i32;

    // Error-Symbol (Used when Symbol-Reads cannot be resolved, e.g. symbol not defined)
    Symbol* error_symbol;
};

// I currently need this so that a workload can analyse the same node multiple times
struct Analysis_Pass 
{
    Workload_Base* origin_workload;
};

struct AST_Info_Key
{
    Analysis_Pass* pass;
    AST::Node* base;
};

struct Node_Passes
{
    Dynamic_Array<Analysis_Pass*> passes;
    AST::Node* base;
};


// ERRORS
enum class Error_Information_Type
{
    ARGUMENT_COUNT,
    MISSING_PARAMETER,
    INVALID_MEMBER,
    ID,
    SYMBOL,
    EXIT_CODE,

    GIVEN_TYPE,
    EXPECTED_TYPE,
    FUNCTION_TYPE,
    BINARY_OP_TYPES,
    CYCLE_WORKLOAD,

    EXPRESSION_RESULT_TYPE,
    CONSTANT_STATUS,
    COMPTIME_MESSAGE,
};

struct Error_Information
{
    Error_Information_Type type;
    union
    {
        Function_Parameter parameter;
        struct {
            int expected;
            int given;
        } invalid_argument_count;
        String* id;
        Symbol* symbol;
        Exit_Code exit_code;
        Datatype* type;
        Datatype_Function* function;
        struct {
            Datatype_Struct* struct_signature;
            String* member_id;
        } invalid_member;
        Workload_Base* cycle_workload;
        struct {
            Datatype* left_type;
            Datatype* right_type;
        } binary_op_types;
        Expression_Result_Type expression_type;
        const char* constant_message;
        const char* comptime_message;
    } options;
};

struct Semantic_Error
{
    const char* msg;
    AST::Node* error_node; // May be null
    Parser::Section section;
    Dynamic_Array<Error_Information> information;
};

void log_semantic_error(const char* msg, AST::Node* node, Parser::Section node_section = Parser::Section::WHOLE);
void semantic_analyser_set_error_flag(bool error_due_to_unknown);
void semantic_error_append_to_string(Semantic_Error e, String* string);





// ANALYSER
struct Semantic_Analyser
{
    // Result
    Dynamic_Array<Semantic_Error> errors;
    ModTree_Program* program;
    Hashtable<AST::Node*, Node_Passes> ast_to_pass_mapping;
    Hashtable<AST_Info_Key, Analysis_Info*> ast_to_info_mapping;

    // Other
    Workload_Base* current_workload;
    Module_Progress* root_module;
    Predefined_Symbols predefined_symbols;
    Workload_Executer* workload_executer;
    Hashtable<AST::Expression*, Datatype_Template_Parameter*> valid_template_parameters;

    // Symbol tables
    Symbol_Table* root_symbol_table;
    Hashset<Symbol_Table*> symbol_lookup_visited;

    // Allocations
    Stack_Allocator comptime_value_allocator;
    Stack_Allocator global_variable_memory_pool;
    Dynamic_Array<Symbol_Table*> allocated_symbol_tables;
    Dynamic_Array<Symbol*> allocated_symbols;
    Dynamic_Array<Analysis_Pass*> allocated_passes;
    Dynamic_Array<Function_Progress*> allocated_function_progresses;
    Dynamic_Array<Operator_Context*> allocated_operator_contexts;
    Stack_Allocator progress_allocator;
};

Semantic_Analyser* semantic_analyser_initialize();
void semantic_analyser_destroy();
void semantic_analyser_reset();
void semantic_analyser_finish();
Function_Progress* analysis_workload_try_get_function_progress(Workload_Base* workload);

Datatype_Function* hardcoded_type_to_signature(Hardcoded_Type type);



