/* 
TODO:
    - Defining static array data
*/

array_bubble_sort :: (a: []int) -> int
{
    i := 0;
    while (i < a.size)
    {
        j := i + 1;
        while (j < a.size) 
        {
            if (a[j] < a[i]) {
                swap := a[i];
                a[i] = a[j];
                a[j] = swap;
            }
            j = j+1;
        }
        i = i+1;
    }
    return 0;
}

array_set_even_constant :: (array: []int, c: int) -> int
{
    i := 0;
    while (i < array.size)
    {
        if even(array[i]) {
            array[i] = c;
        }
        i = i+1;
    }
    return 0;
}

array_print :: (array: []int) -> int
{
    i := 0;
    print_line();
    while (i < array.size) {
        print_i32(array[i]);
        print_line();
        i = i+1;
    }
    return 0;
}

array_fill_from_console :: (array: []int) -> int
{
    i := 0;
    while (i < array.size)
    {
        array[i] = read_i32();
        i = i + 1;
    }
    return 0;
}

main :: () -> int
{
    array: [30]int;
    i := 0;
    while (i < array.size)
    {
        array[i] = i;
        i = i+1;
    }
    a: []int;
    a.data = array.data;
    a.size = array.size;
    array_set_even_constant(a, 7); 

    arr2: [5]int;
    a2: []int;
    a2.size = arr2.size;
    a2.data = arr2.data;
    a2[0] = 3;
    a2[1] = 0;
    a2[2] = 2;
    a2[3] = 1;
    a2[4] = 4;
    array_fill_from_console(a2);
    array_bubble_sort(a2);
    array_print(a2);
    return 0;
}

even :: (a: int) -> bool 
{
    return a % 2 == 0;
}

mul_add :: (a: int, b: int, c: int) -> int
{
    return a * b + c;
}

sum_first :: (n: int) -> int
{
    i := 0;
    sum := 0;
    while (i < 1000) {
        i = i+1;
        sum = sum + i;
    } 
    return sum;
}

fact_rec :: (n: int) -> int
{
    if (n <= 2) return n; 
    return fact_rec(n-1) * n;
}

fib_rec :: (n: int) -> int
{
    if (n <= 2) return 1;
    return fib_rec(n-1) + fib_rec(n-2);
}


/*
    Missing binary statements x++; x--; x+=1; x-=1; x/=1; x*=1;
    Short circuit operation on && and ||

    Next Features:
     * Arrays
     * Structs
     * Predefine functions (print)
     * Casting
     * Strings?
     * OS-Calls/Calls to libraries (print, new/delete)
     * Bytecode Debugger
     * Backend (LLVM or C or just x64 assembly)
     * Float/Int conversion / Maybe implicit?
     * Globals

    UppLang small improvements:
     * Just highlight relevant stuff on parser errors

    Current UppLang features:
     * Expression parsing + evaluation
     * Variable definition/assignment + return
     * Primitive Type System (Int bool float)
     * Scopes
     * If-Else Flow control
     * While loop with break continue
     * Functions with parameters and return types
     * Pointers/Dereferencing

    Nice-to-have Features:
     * Log to window, not to console, maybe something like in a textfield
        -> Would be best with a toast like notification, and something you can focus
     * Work on GUI (Probably necessary for better debugging)
*/