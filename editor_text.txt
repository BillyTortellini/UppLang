add :: (a: i64, b: i64) -> i64 {
    return a + b;
}

main :: () -> void 
{
    scope_test();
    struct_test();
    array_test();
    memory_test();
    cast_test(); 
}

cast_test :: () -> void
{
    {
        f: f32 = 5.68;    
        b: f64 = cast<f64> -2.3;
        f = f + cast<f32>b;
        a := cast<int> f;
        print_i32(a);
        print_line();
        print_f32(f);
        print_line();
    }
    
    {
        a: [2]int;
    
        ap := *a[0];
        &ap = 7;
    
        addr := cast<u64>ap;
        addr = addr + cast<u64>4;
        ap = cast<*int>addr;
    
        &ap = 5;
    
        print_i32(a[0]);
        print_line();
        print_i32(a[1]);
        print_line();
    }
    {
        a := 0;
        a_addr := cast<u64> *a;
        b0 := cast<*byte> (a_addr + cast<u64> 0);
        b1 := cast<*byte> (a_addr + cast<u64> 1);
        b2 := cast<*byte> (a_addr + cast<u64> 2);
        b3 := cast<*byte> (a_addr + cast<u64> 3);
        
        &b0 = cast<byte> 0;
        &b1 = cast<byte> 0;
        &b2 = cast<byte> 1;
        &b3 = cast<byte> 0;
        
        print_i32(a);
        print_line();
    }
    {
        a: [20]int;
        b: []int = cast<[]int> a;
    
        array_fill_random(b, 100);
        array_bubble_sort(b);
    }
    {
        a := 5;
        ap: *int = *a;
    
        b: *void = cast<*void> ap;
        c: *int = cast<*int> b;
        &c = 3;
    
        x: int = 100;
        d := cast<*void>*x;
    
        print_bool(d == b);
        print_line();
        print_i32(a);
        print_line();
    }
    
    {
        a: *void = nullptr;
        if (cast<u64>0 == cast<u64>a) {
            print_line();
            print_line();
            print_i32(420);
            print_line();
            print_line();
        }
        else {
            print_i32(69);
            print_line();
        }
    }
    
    {
        a := add(32, 5);
        print_f32(cast<i32>a);
        print_line();
    }
}

array_fill_random :: (array: []int, max: int) -> void
{
    i := 0;
    while (i < array.size)
    {
        array[i] = random_i32(); // % max;
        if (array[i] < 0) array[i] = -array[i];
        array[i] = array[i] % max;
        i = i+1;
    }
}

memory_test :: () -> void
{
    size := 30;
    a: []int = new [size]int;
    array_fill_random(a, 100);
    array_bubble_sort(a);
    array_print(a);
    delete a;
}

scope_test :: () -> void
{
    a: int = 0;
    x: int = 5;
    {
        x: int = 17;
        a = x;
    }
    print_i32(a);
    print_line();
}

Player :: struct
{
    age: int;
    alive: bool;
    level: int;
}

player_level_up :: (player: *Player) -> void
{
    (&player).level = (&player).level + 1;
}

player_make :: (age: int, alive: bool, level: int) -> Player
{
    player: Player;
    player.age = age;
    player.alive = alive;
    player.level = level;
    return player;
}

player_kill :: (killer: *Player, victim: *Player) -> void
{
    if !(&victim).alive return;
    (&victim).alive = false;
    (&killer).level = (&killer).level + (&victim).level;
}

struct_test :: () -> void
{
    p1 := player_make(69, true, 12);
    p2 := player_make(77, true, 3);

    player_level_up(*p1);
    player_kill(*p1, *p2);

    print_line();
    print_i32(p1.level);
    print_line();
}

array_test :: () -> void
{
    array: [30]int;
    i := 0;
    while (i < array.size)
    {
        array[i] = i;
        i = i+1;
    }
    a: []int;
    a.data = array.data;
    a.size = array.size;

    arr2: [20]int;
    a2: []int;
    a2.size = arr2.size;
    a2.data = arr2.data;
    array_fill_random(a2, a2.size);
    //array_fill_from_console(a2);
    array_bubble_sort(a2);
    array_set_even_constant(a2, 420); 
    array_print(a2);
}

array_bubble_sort :: (a: []int) -> void
{
    i := 0;
    while (i < a.size)
    {
        j := i + 1;
        while (j < a.size) 
        {
            if (a[j] < a[i]) {
                swap := a[i];
                a[i] = a[j];
                a[j] = swap;
            }
            j = j+1;
        }
        i = i+1;
    }
}

array_set_even_constant :: (array: []int, c: int) -> void
{
    i := 0;
    while (i < array.size)
    {
        if even(array[i]) {
            array[i] = c;
        }
        i = i+1;
    }
}

array_print :: (array: []int) -> void
{
    i := 0;
    print_line();
    while (i < array.size) {
        print_i32(array[i]);
        print_line();
        i = i+1;
    }
}

array_fill_from_console :: (array: []int) -> void
{
    i := 0;
    while (i < array.size)
    {
        array[i] = read_i32();
        i = i + 1;
    }
}


even :: (a: int) -> bool 
{
    return a % 2 == 0;
}

mul_add :: (a: int, b: int, c: int) -> int
{
    return a * b + c;
}

sum_first :: (n: int) -> int
{
    i := 0;
    sum := 0;
    while (i < 1000) {
        i = i+1;
        sum = sum + i;
    } 
    return sum;
}

fact_rec :: (n: int) -> int
{
    if (n <= 2) return n; 
    return fact_rec(n-1) * n;
}

fib_rec :: (n: int) -> int
{
    if (n <= 2) return 1;
    return fib_rec(n-1) + fib_rec(n-2);
}

/*
Missing binary statements x++; x--; x+=1; x-=1; x/=1; x*=1;
Short circuit operation on && and ||

Next Features:
* Casting/Implicit conversions
* Strings
* OS-Calls/Calls to libraries (print, new/delete)
* Bytecode Debugger
* Backend (LLVM or C or just x64 assembly)
* Globals

UppLang small improvements:
* Just highlight relevant stuff on parser errors

Current UppLang features:
* Expression parsing + evaluation
* Variable definition/assignment + return
* Primitive Type System (Int bool float)
* Scopes
* If-Else Flow control
* While loop with break continue
* Functions with parameters and return types
* Pointers/Dereferencing + new/delete
* Arrays
* Structs
*/