
add :: (a: int, b: int) => int
	return a + b

add :: (a: float, b: float) => float
	return a + b

add :: (a: $T, b: T) => T
	return a + b + 3

in_range :: (value: float, expected: float, epsilon: float) => bool
	return value >= expected - epsilon && value <= expected + epsilon

Node :: struct
	value: int

add :: (node: *Node, a: int)
	node.value += a

add :: (node: *Node, b: bool)
	if b
		node.value *= 2

add :: (node: *Node, a: int, b: int) => int
	node.value = node.value * a + b
	return node.value

main :: ()
	import Upp~type_of
	
	a := add(5, 10)
	assert(type_of(a) == int)
	f := add(5.5, 10.3)
	assert(type_of(f) == float)
	assert(in_range(f, 15.8, 0.001))
	
	x: Upp~u64 = 5
	z := add(x, x)
	assert(type_of(z) == Upp~u64)
	
	n: Node = .{20}
	add(n, 5)
	add(n, true)
	add(n, 2, 5)
	assert(n.value == 105)
